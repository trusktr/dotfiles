"use strict";
/* IMPORT */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const atomically_1 = require("atomically");
const envPaths = require("env-paths");
const node_fetch_1 = require("node-fetch");
const path = require("path");
const vscode = require("vscode");
/* MAIN */
const beggar = (options) => __awaiter(void 0, void 0, void 0, function* () {
    /* VARIABLES */
    var _a, _b, _c, _d, _e;
    const { id, title, url, actions } = options;
    const yesTitle = ((_a = actions === null || actions === void 0 ? void 0 : actions.yes) === null || _a === void 0 ? void 0 : _a.title) || 'Donate';
    const yesWebhook = (_b = actions === null || actions === void 0 ? void 0 : actions.yes) === null || _b === void 0 ? void 0 : _b.webhook;
    const noTitle = ((_c = actions === null || actions === void 0 ? void 0 : actions.no) === null || _c === void 0 ? void 0 : _c.title) || 'Sorry, I can\'t :(';
    const noWebhook = (_d = actions === null || actions === void 0 ? void 0 : actions.no) === null || _d === void 0 ? void 0 : _d.webhook;
    const cancelWebhook = (_e = actions === null || actions === void 0 ? void 0 : actions.cancel) === null || _e === void 0 ? void 0 : _e.webhook;
    const isPromptDisabled = vscode.workspace.getConfiguration().get('donations.disablePrompt') === true;
    const isTelemetryDisabled = (vscode.env['isTelemetryEnabled'] === false || vscode.workspace.getConfiguration().get('telemetry.enableTelemetry') === false);
    const folderPath = envPaths('vscode-beggar', { suffix: '' }).data;
    const filePath = path.join(folderPath, `${id}.json`);
    if (isPromptDisabled)
        return;
    /* CHECKING CURRENT STATE */
    let state;
    try {
        const stateRaw = yield (0, atomically_1.readFile)(filePath, { encoding: 'utf8' });
        state = JSON.parse(stateRaw);
        if ('state' in state && state.state !== 0)
            return; // Already asked
    }
    catch (_f) {
        try { // Setting touchbase state
            const state = { state: 0, timestamp: Date.now() };
            yield (0, atomically_1.writeFile)(filePath, JSON.stringify(state));
        }
        catch (_g) { }
        return; // Asking another time, it's too soon now
    }
    /* CHECKING ELAPSED ENOUGH TIME */
    const elapsed = Date.now() - (state.timestamp || Infinity);
    if (elapsed < 86400000)
        return; // Too soon, let's wait at least a day
    /* WAITING */
    const delay = Math.round(30000 + (120000 * Math.random())); // Waiting between 30s and 2:30m
    yield new Promise(resolve => setTimeout(resolve, delay));
    /* SETTING TRIGGERED STATE */
    try {
        const state = { state: 1, timestamp: Date.now() };
        yield (0, atomically_1.writeFile)(filePath, JSON.stringify(state));
    }
    catch (_h) {
        return; // Attempting another time, or we'll bother people multiple times later on
    }
    /* ASKING */
    const result = yield vscode.window.showErrorMessage(title, noTitle, yesTitle); // Error => Persistent message
    if (!result) { // Cancel
        try { // Setting touchbase state, asking again later for a clearer answer
            const state = { state: 0, timestamp: Date.now() };
            yield (0, atomically_1.writeFile)(filePath, JSON.stringify(state));
        }
        catch (_j) { }
        if (!isTelemetryDisabled && cancelWebhook)
            (0, node_fetch_1.default)(cancelWebhook);
        return;
    }
    else if (result === yesTitle) { // Yes
        vscode.env.openExternal(vscode.Uri.parse(url));
        if (!isTelemetryDisabled && yesWebhook)
            (0, node_fetch_1.default)(yesWebhook);
        return true;
    }
    else if (result === noTitle) { // No
        if (!isTelemetryDisabled && noWebhook)
            (0, node_fetch_1.default)(noWebhook);
        return false;
    }
});
/* EXPORT */
module.exports = beggar;
module.exports.default = beggar;
Object.defineProperty(module.exports, "__esModule", { value: true });
