/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 742:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */



function peg$subclass(child, parent) {
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message  = message;
  this.expected = expected;
  this.found    = found;
  this.location = location;
  this.name     = "SyntaxError";

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },

        "class": function(expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array
              ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
              : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },

        any: function(expectation) {
          return "any character";
        },

        end: function(expectation) {
          return "end of input";
        },

        other: function(expectation) {
          return expectation.description;
        }
      };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/"/g,  '\\"')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/\]/g, '\\]')
      .replace(/\^/g, '\\^')
      .replace(/-/g,  '\\-')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = new Array(expected.length),
        i, j;

    for (i = 0; i < expected.length; i++) {
      descriptions[i] = describeExpectation(expected[i]);
    }

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + " or " + descriptions[1];

      default:
        return descriptions.slice(0, -1).join(", ")
          + ", or "
          + descriptions[descriptions.length - 1];
    }
  }

  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }

  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

function peg$parse(input, options) {
  options = options !== void 0 ? options : {};

  var peg$FAILED = {},

      peg$startRuleFunctions = { regexp: peg$parseregexp },
      peg$startRuleFunction  = peg$parseregexp,

      peg$c0 = "|",
      peg$c1 = peg$literalExpectation("|", false),
      peg$c2 = function(match, alternate) {
      	if(alternate) {
      		const body = alternate[1].type === TokenType.ALTERNATE ? [match, ...alternate[1].body] : [match, alternate[1]]

      		return { type: TokenType.ALTERNATE, body: body }
      	}
      	else {
      		return match
      	}
      },
      peg$c3 = "/",
      peg$c4 = peg$literalExpectation("/", false),
      peg$c5 = function(body, modifiers) {
      	if(modifiers) {
      		return { type: TokenType.PATTERN, body: body, modifiers: modifiers }
      	}
      	else {
      		return { type: TokenType.PATTERN, body: body }
      	}
      },
      peg$c6 = "(",
      peg$c7 = peg$literalExpectation("(", false),
      peg$c8 = ")",
      peg$c9 = peg$literalExpectation(")", false),
      peg$c10 = function(modifier, begin, matches, end) {
      	const body = []

      	if(modifier) {
      		body.push(modifier[1])
      	}

      	if(begin) {
      		body.push(begin)
      	}

      	body.push(...matches.flat())

      	if(end) {
      		body.push(end)
      	}

      	return { type: TokenType.MATCH, body: body }
      },
      peg$c11 = "^",
      peg$c12 = peg$literalExpectation("^", false),
      peg$c13 = function() { return { type: TokenType.BEGIN } },
      peg$c14 = "$",
      peg$c15 = peg$literalExpectation("$", false),
      peg$c16 = function() { return { type: TokenType.END } },
      peg$c17 = "?",
      peg$c18 = peg$literalExpectation("?", false),
      peg$c19 = function(modifiers) { return { type: TokenType.MODIFIER, ...modifiers } },
      peg$c20 = /^[gimsuxyUJX]/,
      peg$c21 = peg$classExpectation(["g", "i", "m", "s", "u", "x", "y", "U", "J", "X"], false, false),
      peg$c22 = "-",
      peg$c23 = peg$literalExpectation("-", false),
      peg$c24 = function(positive, negative) { return { positive: positive, negative: negative } },
      peg$c25 = function(positive) { return { positive: positive, negative: [] } },
      peg$c26 = function(negative) { return { positive: [], negative: negative } },
      peg$c27 = function(submatch, quantifier) {
      	if(submatch.type === TokenType.LITERAL && submatch.text.length > 1) {
      		return [
      			{ type: TokenType.LITERAL, text: submatch.text.substr(0, submatch.text.length - 1) },
      			{ type: TokenType.QUANTIFIED, body: { type: TokenType.LITERAL, text: submatch.text.substr(-1) }, quantifier: quantifier }
      		]
      	}
      	else {
      		return { type: TokenType.QUANTIFIED, body: submatch, quantifier: quantifier }
      	}
      },
      peg$c28 = peg$otherExpectation("Quantifier"),
      peg$c29 = function(quantity, notgreedy) { quantity.greedy = !notgreedy; return quantity },
      peg$c30 = "{",
      peg$c31 = peg$literalExpectation("{", false),
      peg$c32 = ",",
      peg$c33 = peg$literalExpectation(",", false),
      peg$c34 = "}",
      peg$c35 = peg$literalExpectation("}", false),
      peg$c36 = function(min, max) { return { type: TokenType.QUANTIFIER, min: min, max: max } },
      peg$c37 = ",}",
      peg$c38 = peg$literalExpectation(",}", false),
      peg$c39 = function(min) { return { type: TokenType.QUANTIFIER, min: min, max: Infinity } },
      peg$c40 = function(value) { return { type: TokenType.QUANTIFIER, min: value, max: value } },
      peg$c41 = "+",
      peg$c42 = peg$literalExpectation("+", false),
      peg$c43 = function() { return { type: TokenType.QUANTIFIER, min: 1, max: Infinity } },
      peg$c44 = "*",
      peg$c45 = peg$literalExpectation("*", false),
      peg$c46 = function() { return { type: TokenType.QUANTIFIER, min: 0, max: Infinity } },
      peg$c47 = function() { return { type: TokenType.QUANTIFIER, min: 0, max: 1 } },
      peg$c48 = /^[0-9]/,
      peg$c49 = peg$classExpectation([["0", "9"]], false, false),
      peg$c50 = function(num) { return +num.join('') },
      peg$c51 = function(body) { return body },
      peg$c52 = function(regexp) { return { type: TokenType.CAPTURE_GROUP, body: regexp } },
      peg$c53 = "?:",
      peg$c54 = peg$literalExpectation("?:", false),
      peg$c55 = function(regexp) { return { type: TokenType.NON_CAPTURE_GROUP, body: regexp } },
      peg$c56 = "?<",
      peg$c57 = peg$literalExpectation("?<", false),
      peg$c58 = /^[0-9a-zA-Z_]/,
      peg$c59 = peg$classExpectation([["0", "9"], ["a", "z"], ["A", "Z"], "_"], false, false),
      peg$c60 = ">",
      peg$c61 = peg$literalExpectation(">", false),
      peg$c62 = function(name, regexp) { return { type: TokenType.NAMED_GROUP, name: name.join(''), body: regexp } },
      peg$c63 = "?<=",
      peg$c64 = peg$literalExpectation("?<=", false),
      peg$c65 = function(regexp) { return { type: TokenType.POSITIVE_LOOKBEHIND, body: regexp } },
      peg$c66 = "?<!",
      peg$c67 = peg$literalExpectation("?<!", false),
      peg$c68 = function(regexp) { return { type: TokenType.NEGATIVE_LOOKBEHIND, body: regexp } },
      peg$c69 = "?=",
      peg$c70 = peg$literalExpectation("?=", false),
      peg$c71 = function(regexp) { return { type: TokenType.POSITIVE_LOOKAHEAD, body: regexp } },
      peg$c72 = "?!",
      peg$c73 = peg$literalExpectation("?!", false),
      peg$c74 = function(regexp) { return { type: TokenType.NEGATIVE_LOOKAHEAD, body: regexp } },
      peg$c75 = ":",
      peg$c76 = peg$literalExpectation(":", false),
      peg$c77 = function(modifiers, regexp) { return { type: TokenType.MODIFIED_GROUP, modifiers: modifiers, body: regexp } },
      peg$c78 = peg$otherExpectation("CharacterSet"),
      peg$c79 = "[",
      peg$c80 = peg$literalExpectation("[", false),
      peg$c81 = "]",
      peg$c82 = peg$literalExpectation("]", false),
      peg$c83 = function(negated, body) { return { type: TokenType.CHARSET, body: body, negated: !!negated} },
      peg$c84 = peg$otherExpectation("CharacterRange"),
      peg$c85 = function(begin, end) { return { type: TokenType.RANGE, begin: begin, end: end } },
      peg$c86 = peg$otherExpectation("Character"),
      peg$c87 = /^[^\\\]]/,
      peg$c88 = peg$classExpectation(["\\", "]"], true, false),
      peg$c89 = function(value) { return { type: TokenType.LITERAL, text: value } },
      peg$c90 = ".",
      peg$c91 = peg$literalExpectation(".", false),
      peg$c92 = function() { return { type: TokenType.ANY } },
      peg$c93 = peg$otherExpectation("Literal"),
      peg$c94 = /^[^|\\\/.[()?+*$\^]/,
      peg$c95 = peg$classExpectation(["|", "\\", "/", ".", "[", "(", ")", "?", "+", "*", "$", "^"], true, false),
      peg$c96 = function(value) { return { type: TokenType.LITERAL, text: value.join('') } },
      peg$c97 = "\\",
      peg$c98 = peg$literalExpectation("\\", false),
      peg$c99 = /^[1-9]/,
      peg$c100 = peg$classExpectation([["1", "9"]], false, false),
      peg$c101 = function(code) { return { type: TokenType.BACK_REFERENCE, code: code } },
      peg$c102 = "\\b",
      peg$c103 = peg$literalExpectation("\\b", false),
      peg$c104 = function() { return { type: TokenType.BACKSPACE } },
      peg$c105 = "\\r",
      peg$c106 = peg$literalExpectation("\\r", false),
      peg$c107 = function() { return { type: TokenType.CARRIAGE_RETURN } },
      peg$c108 = "\\c",
      peg$c109 = peg$literalExpectation("\\c", false),
      peg$c110 = peg$anyExpectation(),
      peg$c111 = function(code) { return { type: TokenType.CONTROL, code: code } },
      peg$c112 = "\\d",
      peg$c113 = peg$literalExpectation("\\d", false),
      peg$c114 = function() { return { type: TokenType.DIGIT } },
      peg$c115 = "\\D",
      peg$c116 = peg$literalExpectation("\\D", false),
      peg$c117 = function() { return { type: TokenType.NON_DIGIT } },
      peg$c118 = "\\f",
      peg$c119 = peg$literalExpectation("\\f", false),
      peg$c120 = function() { return { type: TokenType.FORM_FEED } },
      peg$c121 = "\\x",
      peg$c122 = peg$literalExpectation("\\x", false),
      peg$c123 = /^[0-9a-fA-F]/,
      peg$c124 = peg$classExpectation([["0", "9"], ["a", "f"], ["A", "F"]], false, false),
      peg$c125 = function(code) { return { type: TokenType.HEX, code: code.join('') } },
      peg$c126 = "\\n",
      peg$c127 = peg$literalExpectation("\\n", false),
      peg$c128 = function() { return { type: TokenType.LINE_FEED } },
      peg$c129 = "\\k<",
      peg$c130 = peg$literalExpectation("\\k<", false),
      peg$c131 = function(name) { return { type: TokenType.NAMED_BACK_REFERENCE, name: name } },
      peg$c132 = "\\0",
      peg$c133 = peg$literalExpectation("\\0", false),
      peg$c134 = function() { return { type: TokenType.NUL } },
      peg$c135 = /^[0-7]/,
      peg$c136 = peg$classExpectation([["0", "7"]], false, false),
      peg$c137 = function(code) { return { type: TokenType.OCTAL, code: code.join('') } },
      peg$c138 = "\\t",
      peg$c139 = peg$literalExpectation("\\t", false),
      peg$c140 = function() { return { type: TokenType.TAB } },
      peg$c141 = "\\u{",
      peg$c142 = peg$literalExpectation("\\u{", false),
      peg$c143 = function(code) { return { type: TokenType.UNICODE, code: code.join('') } },
      peg$c144 = "\\p{",
      peg$c145 = peg$literalExpectation("\\p{", false),
      peg$c146 = /^[0-9a-zA-Z_=]/,
      peg$c147 = peg$classExpectation([["0", "9"], ["a", "z"], ["A", "Z"], "_", "="], false, false),
      peg$c148 = function(property) { return { type: TokenType.UNICODE_PROPERTY, property: property.join('') } },
      peg$c149 = "\\P{",
      peg$c150 = peg$literalExpectation("\\P{", false),
      peg$c151 = function(property) { return { type: TokenType.NON_UNICODE_PROPERTY, property: property.join('') } },
      peg$c152 = "\\u",
      peg$c153 = peg$literalExpectation("\\u", false),
      peg$c154 = function(code) { return { type: TokenType.UTF16, code: code.join('') } },
      peg$c155 = "\\v",
      peg$c156 = peg$literalExpectation("\\v", false),
      peg$c157 = function() { return { type: TokenType.VERTICAL_TAB } },
      peg$c158 = "\\s",
      peg$c159 = peg$literalExpectation("\\s", false),
      peg$c160 = function() { return { type: TokenType.WHITE_SPACE } },
      peg$c161 = "\\S",
      peg$c162 = peg$literalExpectation("\\S", false),
      peg$c163 = function() { return { type: TokenType.NON_WHITE_SPACE } },
      peg$c164 = function() { return { type: TokenType.WORD_BOUNDARY } },
      peg$c165 = "\\B",
      peg$c166 = peg$literalExpectation("\\B", false),
      peg$c167 = function() { return { type: TokenType.NON_WORD_BOUNDARY } },
      peg$c168 = "\\w",
      peg$c169 = peg$literalExpectation("\\w", false),
      peg$c170 = function() { return { type: TokenType.WORD } },
      peg$c171 = "\\W",
      peg$c172 = peg$literalExpectation("\\W", false),
      peg$c173 = function() { return { type: TokenType.NON_WORD } },
      peg$c174 = function(code) { return { type: TokenType.ESCAPE, code: code } },

      peg$currPos          = 0,
      peg$savedPos         = 0,
      peg$posDetailsCache  = [{ line: 1, column: 1 }],
      peg$maxFailPos       = 0,
      peg$maxFailExpected  = [],
      peg$silentFails      = 0,

      peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location
    );
  }

  function error(message, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return { type: "literal", text: text, ignoreCase: ignoreCase };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

  function peg$anyExpectation() {
    return { type: "any" };
  }

  function peg$endExpectation() {
    return { type: "end" };
  }

  function peg$otherExpectation(description) {
    return { type: "other", description: description };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos], p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line:   details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos),
        endPosDetails   = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line:   startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line:   endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) { return; }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$parseregexp() {
    var s0;

    s0 = peg$parsepatternMod();
    if (s0 === peg$FAILED) {
      s0 = peg$parsepattern();
    }

    return s0;
  }

  function peg$parsepattern() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parsematch();
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 124) {
        s3 = peg$c0;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c1); }
      }
      if (s3 !== peg$FAILED) {
        s4 = peg$parsepattern();
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsepatternMod() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 47) {
      s1 = peg$c3;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c4); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsepattern();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 47) {
          s3 = peg$c3;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c4); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parsemodifierPositive();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c5(s2, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsematch() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 40) {
      s2 = peg$c6;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c7); }
    }
    if (s2 !== peg$FAILED) {
      s3 = peg$parsemodifier();
      if (s3 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 41) {
          s4 = peg$c8;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c9); }
        }
        if (s4 !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsebegin();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parsequantifier();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$parsequantified();
          if (s5 === peg$FAILED) {
            s5 = peg$parsesubmatch();
          }
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parsequantified();
            if (s5 === peg$FAILED) {
              s5 = peg$parsesubmatch();
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseend();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c10(s1, s2, s4, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsesubmatch() {
    var s0;

    s0 = peg$parsesubexp();
    if (s0 === peg$FAILED) {
      s0 = peg$parsecharset();
      if (s0 === peg$FAILED) {
        s0 = peg$parseterminal();
      }
    }

    return s0;
  }

  function peg$parsebegin() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 94) {
      s1 = peg$c11;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c12); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c13();
    }
    s0 = s1;

    return s0;
  }

  function peg$parseend() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 36) {
      s1 = peg$c14;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c15); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c16();
    }
    s0 = s1;

    return s0;
  }

  function peg$parsemodifier() {
    var s0, s1, s2;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 63) {
      s1 = peg$c17;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c18); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsemodifierSpec();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c19(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsemodifierSpec() {
    var s0;

    s0 = peg$parsemodifierPositiveNegative();
    if (s0 === peg$FAILED) {
      s0 = peg$parsemodifierPositive();
      if (s0 === peg$FAILED) {
        s0 = peg$parsemodifierNegative();
      }
    }

    return s0;
  }

  function peg$parsemodifierPositiveNegative() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = [];
    if (peg$c20.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c21); }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c20.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c21); }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 45) {
        s2 = peg$c22;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c23); }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        if (peg$c20.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c21); }
        }
        if (s4 !== peg$FAILED) {
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            if (peg$c20.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c21); }
            }
          }
        } else {
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c24(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsemodifierPositive() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    if (peg$c20.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c21); }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c20.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c21); }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c25(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsemodifierNegative() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 45) {
      s1 = peg$c22;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c23); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (peg$c20.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c21); }
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c20.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c21); }
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c26(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsequantified() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parsesubmatch();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsequantifier();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c27(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsequantifier() {
    var s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsequantifierSpec();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsegreedyFlag();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c29(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c28); }
    }

    return s0;
  }

  function peg$parsequantifierSpec() {
    var s0;

    s0 = peg$parsequantifierSpecFull();
    if (s0 === peg$FAILED) {
      s0 = peg$parsequantifierSpecAtLeast();
      if (s0 === peg$FAILED) {
        s0 = peg$parsequantifierSpecExact();
        if (s0 === peg$FAILED) {
          s0 = peg$parsequantifierRequired();
          if (s0 === peg$FAILED) {
            s0 = peg$parsequantifierAny();
            if (s0 === peg$FAILED) {
              s0 = peg$parsequantifierOptional();
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parsequantifierSpecFull() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      s1 = peg$c30;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c31); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseinteger();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s3 = peg$c32;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c33); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseinteger();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 125) {
              s5 = peg$c34;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c35); }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c36(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsequantifierSpecAtLeast() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      s1 = peg$c30;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c31); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseinteger();
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c37) {
          s3 = peg$c37;
          peg$currPos += 2;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c38); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c39(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsequantifierSpecExact() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      s1 = peg$c30;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c31); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseinteger();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 125) {
          s3 = peg$c34;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c35); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c40(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsequantifierRequired() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 43) {
      s1 = peg$c41;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c42); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c43();
    }
    s0 = s1;

    return s0;
  }

  function peg$parsequantifierAny() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 42) {
      s1 = peg$c44;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c45); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c46();
    }
    s0 = s1;

    return s0;
  }

  function peg$parsequantifierOptional() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 63) {
      s1 = peg$c17;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c18); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c47();
    }
    s0 = s1;

    return s0;
  }

  function peg$parsegreedyFlag() {
    var s0;

    if (input.charCodeAt(peg$currPos) === 63) {
      s0 = peg$c17;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c18); }
    }

    return s0;
  }

  function peg$parseinteger() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    if (peg$c48.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c49); }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c48.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c49); }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c50(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsesubexp() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 40) {
      s1 = peg$c6;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c7); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsepositiveLookbehind();
      if (s2 === peg$FAILED) {
        s2 = peg$parsenegativeLookbehind();
        if (s2 === peg$FAILED) {
          s2 = peg$parsepositiveLookahead();
          if (s2 === peg$FAILED) {
            s2 = peg$parsenegativeLookahead();
            if (s2 === peg$FAILED) {
              s2 = peg$parsegroupNamed();
              if (s2 === peg$FAILED) {
                s2 = peg$parsegroupNoCapture();
                if (s2 === peg$FAILED) {
                  s2 = peg$parsegroupModifiers();
                  if (s2 === peg$FAILED) {
                    s2 = peg$parsemodifier();
                    if (s2 === peg$FAILED) {
                      s2 = peg$parsegroupCapture();
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 41) {
          s3 = peg$c8;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c9); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c51(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsegroupCapture() {
    var s0, s1;

    s0 = peg$currPos;
    s1 = peg$parseregexp();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c52(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsegroupNoCapture() {
    var s0, s1, s2;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c53) {
      s1 = peg$c53;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c54); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseregexp();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c55(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsegroupNamed() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c56) {
      s1 = peg$c56;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c57); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (peg$c58.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c59); }
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c58.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c59); }
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 62) {
          s3 = peg$c60;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c61); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseregexp();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c62(s2, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsepositiveLookbehind() {
    var s0, s1, s2;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3) === peg$c63) {
      s1 = peg$c63;
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c64); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseregexp();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c65(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsenegativeLookbehind() {
    var s0, s1, s2;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3) === peg$c66) {
      s1 = peg$c66;
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c67); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseregexp();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c68(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsepositiveLookahead() {
    var s0, s1, s2;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c69) {
      s1 = peg$c69;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c70); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseregexp();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c71(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsenegativeLookahead() {
    var s0, s1, s2;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c72) {
      s1 = peg$c72;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c73); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseregexp();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c74(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsegroupModifiers() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 63) {
      s1 = peg$c17;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c18); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsemodifierSpec();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 58) {
          s3 = peg$c75;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c76); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parseregexp();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c77(s2, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsecharset() {
    var s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      s1 = peg$c79;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c80); }
    }
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 94) {
        s2 = peg$c11;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c12); }
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parsecharsetRange();
        if (s4 === peg$FAILED) {
          s4 = peg$parsecharsetTerminal();
        }
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsecharsetRange();
          if (s4 === peg$FAILED) {
            s4 = peg$parsecharsetTerminal();
          }
        }
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 93) {
            s4 = peg$c81;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c82); }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c83(s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c78); }
    }

    return s0;
  }

  function peg$parsecharsetRange() {
    var s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsecharsetTerminal();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 45) {
        s2 = peg$c22;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c23); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parsecharsetTerminal();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c85(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c84); }
    }

    return s0;
  }

  function peg$parsecharsetTerminal() {
    var s0, s1;

    peg$silentFails++;
    s0 = peg$parsecharsetEscapedCharacter();
    if (s0 === peg$FAILED) {
      s0 = peg$parsecharsetLiteral();
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c86); }
    }

    return s0;
  }

  function peg$parsecharsetLiteral() {
    var s0, s1;

    s0 = peg$currPos;
    if (peg$c87.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c88); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c89(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsecharsetEscapedCharacter() {
    var s0;

    s0 = peg$parsebackspaceCharacter();
    if (s0 === peg$FAILED) {
      s0 = peg$parsecontrolCharacter();
      if (s0 === peg$FAILED) {
        s0 = peg$parsedigitCharacter();
        if (s0 === peg$FAILED) {
          s0 = peg$parsenonDigitCharacter();
          if (s0 === peg$FAILED) {
            s0 = peg$parseformFeedCharacter();
            if (s0 === peg$FAILED) {
              s0 = peg$parselineFeedCharacter();
              if (s0 === peg$FAILED) {
                s0 = peg$parsecarriageReturnCharacter();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsewhiteSpaceCharacter();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsenonWhiteSpaceCharacter();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsetabCharacter();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseverticalTabCharacter();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsewordCharacter();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parsenonWordCharacter();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parseoctalCharacter();
                              if (s0 === peg$FAILED) {
                                s0 = peg$parsehexCharacter();
                                if (s0 === peg$FAILED) {
                                  s0 = peg$parseutf16Character();
                                  if (s0 === peg$FAILED) {
                                    s0 = peg$parseunicodeCharacter();
                                    if (s0 === peg$FAILED) {
                                      s0 = peg$parsenullCharacter();
                                      if (s0 === peg$FAILED) {
                                        s0 = peg$parseotherEscaped();
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parseterminal() {
    var s0;

    s0 = peg$parseanyCharacter();
    if (s0 === peg$FAILED) {
      s0 = peg$parseescapedCharacter();
      if (s0 === peg$FAILED) {
        s0 = peg$parseliteral();
      }
    }

    return s0;
  }

  function peg$parseanyCharacter() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 46) {
      s1 = peg$c90;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c91); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c92();
    }
    s0 = s1;

    return s0;
  }

  function peg$parseliteral() {
    var s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = [];
    if (peg$c94.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c95); }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c94.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c95); }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c96(s1);
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c93); }
    }

    return s0;
  }

  function peg$parseescapedCharacter() {
    var s0;

    s0 = peg$parsewordBoundaryCharacter();
    if (s0 === peg$FAILED) {
      s0 = peg$parsenonWordBoundaryCharacter();
      if (s0 === peg$FAILED) {
        s0 = peg$parsecontrolCharacter();
        if (s0 === peg$FAILED) {
          s0 = peg$parsedigitCharacter();
          if (s0 === peg$FAILED) {
            s0 = peg$parsenonDigitCharacter();
            if (s0 === peg$FAILED) {
              s0 = peg$parseformFeedCharacter();
              if (s0 === peg$FAILED) {
                s0 = peg$parselineFeedCharacter();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsecarriageReturnCharacter();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsewhiteSpaceCharacter();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsenonWhiteSpaceCharacter();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parsetabCharacter();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parseverticalTabCharacter();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parsewordCharacter();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parsenonWordCharacter();
                              if (s0 === peg$FAILED) {
                                s0 = peg$parsebackReference();
                                if (s0 === peg$FAILED) {
                                  s0 = peg$parsenamedBackReference();
                                  if (s0 === peg$FAILED) {
                                    s0 = peg$parseoctalCharacter();
                                    if (s0 === peg$FAILED) {
                                      s0 = peg$parsehexCharacter();
                                      if (s0 === peg$FAILED) {
                                        s0 = peg$parseutf16Character();
                                        if (s0 === peg$FAILED) {
                                          s0 = peg$parseunicodeCharacter();
                                          if (s0 === peg$FAILED) {
                                            s0 = peg$parseunicodeProperty();
                                            if (s0 === peg$FAILED) {
                                              s0 = peg$parsenonUnicodeProperty();
                                              if (s0 === peg$FAILED) {
                                                s0 = peg$parsenullCharacter();
                                                if (s0 === peg$FAILED) {
                                                  s0 = peg$parseotherEscaped();
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parsebackReference() {
    var s0, s1, s2;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 92) {
      s1 = peg$c97;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c98); }
    }
    if (s1 !== peg$FAILED) {
      if (peg$c99.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c100); }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c101(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsebackspaceCharacter() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c102) {
      s1 = peg$c102;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c103); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c104();
    }
    s0 = s1;

    return s0;
  }

  function peg$parsecarriageReturnCharacter() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c105) {
      s1 = peg$c105;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c106); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c107();
    }
    s0 = s1;

    return s0;
  }

  function peg$parsecontrolCharacter() {
    var s0, s1, s2;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c108) {
      s1 = peg$c108;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c109); }
    }
    if (s1 !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c110); }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c111(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsedigitCharacter() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c112) {
      s1 = peg$c112;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c113); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c114();
    }
    s0 = s1;

    return s0;
  }

  function peg$parsenonDigitCharacter() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c115) {
      s1 = peg$c115;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c116); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c117();
    }
    s0 = s1;

    return s0;
  }

  function peg$parseformFeedCharacter() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c118) {
      s1 = peg$c118;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c119); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c120();
    }
    s0 = s1;

    return s0;
  }

  function peg$parsehexCharacter() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c121) {
      s1 = peg$c121;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c122); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (peg$c123.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c124); }
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c123.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c124); }
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c125(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parselineFeedCharacter() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c126) {
      s1 = peg$c126;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c127); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c128();
    }
    s0 = s1;

    return s0;
  }

  function peg$parsenamedBackReference() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3) === peg$c129) {
      s1 = peg$c129;
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c130); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (peg$c58.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c59); }
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c58.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c59); }
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 62) {
          s3 = peg$c60;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c61); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c131(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsenullCharacter() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c132) {
      s1 = peg$c132;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c133); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c134();
    }
    s0 = s1;

    return s0;
  }

  function peg$parseoctalCharacter() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c132) {
      s1 = peg$c132;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c133); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (peg$c135.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c136); }
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c135.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c136); }
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c137(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsetabCharacter() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c138) {
      s1 = peg$c138;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c139); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c140();
    }
    s0 = s1;

    return s0;
  }

  function peg$parseunicodeCharacter() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3) === peg$c141) {
      s1 = peg$c141;
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c142); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (peg$c123.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c124); }
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c123.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c124); }
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 125) {
          s3 = peg$c34;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c35); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c143(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseunicodeProperty() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3) === peg$c144) {
      s1 = peg$c144;
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c145); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (peg$c146.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c147); }
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c146.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c147); }
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 125) {
          s3 = peg$c34;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c35); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c148(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsenonUnicodeProperty() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3) === peg$c149) {
      s1 = peg$c149;
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c150); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (peg$c146.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c147); }
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c146.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c147); }
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 125) {
          s3 = peg$c34;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c35); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c151(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseutf16Character() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c152) {
      s1 = peg$c152;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c153); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (peg$c123.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c124); }
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c123.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c124); }
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c154(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseverticalTabCharacter() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c155) {
      s1 = peg$c155;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c156); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c157();
    }
    s0 = s1;

    return s0;
  }

  function peg$parsewhiteSpaceCharacter() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c158) {
      s1 = peg$c158;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c159); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c160();
    }
    s0 = s1;

    return s0;
  }

  function peg$parsenonWhiteSpaceCharacter() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c161) {
      s1 = peg$c161;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c162); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c163();
    }
    s0 = s1;

    return s0;
  }

  function peg$parsewordBoundaryCharacter() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c102) {
      s1 = peg$c102;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c103); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c164();
    }
    s0 = s1;

    return s0;
  }

  function peg$parsenonWordBoundaryCharacter() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c165) {
      s1 = peg$c165;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c166); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c167();
    }
    s0 = s1;

    return s0;
  }

  function peg$parsewordCharacter() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c168) {
      s1 = peg$c168;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c169); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c170();
    }
    s0 = s1;

    return s0;
  }

  function peg$parsenonWordCharacter() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c171) {
      s1 = peg$c171;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c172); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c173();
    }
    s0 = s1;

    return s0;
  }

  function peg$parseotherEscaped() {
    var s0, s1, s2;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 92) {
      s1 = peg$c97;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c98); }
    }
    if (s1 !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c110); }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c174(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }


  	const { TokenType } = __nccwpck_require__(446)


  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
}

module.exports = {
  SyntaxError: peg$SyntaxError,
  parse:       peg$parse
};


/***/ }),

/***/ 873:
/***/ ((module) => {

const ESCAPE_REGEX = /[-|\\{}()[\]^$+*?.]/g

function escape(value) {
	return value.replace(ESCAPE_REGEX, '\\$&')
}

module.exports = {
	escape
}


/***/ }),

/***/ 712:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const { TokenType } = __nccwpck_require__(446)
const { escape } = __nccwpck_require__(873)
const { isRegExp } = __nccwpck_require__(95)
const { parse } = __nccwpck_require__(51)
const { stringify } = __nccwpck_require__(221)
const { transform } = __nccwpck_require__(784)
const { Flavor, translate } = __nccwpck_require__(238)
const { visit } = __nccwpck_require__(451)

module.exports = {
	Flavor,
	TokenType,
	escape,
	isRegExp,
	parse,
	stringify,
	translate,
	transform,
	visit
}


/***/ }),

/***/ 95:
/***/ ((module) => {

function isRegExp(value) {
	return Object.prototype.toString.call(value) === '[object RegExp]'
}

module.exports = {
	isRegExp
}


/***/ }),

/***/ 51:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const { parse: peg$parse } = __nccwpck_require__(742)

function parse(value) {
	if(typeof value === 'string') {
		return peg$parse(value)
	}
	else if(isRegExp(value)) {
		return peg$parse(value.toString())
	}
	else {
		throw new TypeError('The regexp to parse must be represented as a string.')
	}
}

module.exports = {
	parse
}


/***/ }),

/***/ 221:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const { TokenType } = __nccwpck_require__(446)
const { isRegExp } = __nccwpck_require__(95)

function stringify(tokens) {
	if(Array.isArray(tokens)) {
		let result = ''

		for(const token of tokens) {
			result += stringify(token)
		}

		return result
	}
	else if(isRegExp(tokens)) {
		return tokens.toString()
	}
	else if(tokens) {
		return toString(tokens, '')
	}
	else {
		return ''
	}
}

function toString(value, result) {
	if(value.type === TokenType.ALTERNATE) { // {{{
		for(let i = 0, l = value.body.length; i < l; i++) {
			if(i !== 0) {
				result += '|'
			}

			result = toString(value.body[i], result)
		}
	} // }}}
	else if(value.type === TokenType.ANY) { // {{{
		result += '.'
	} // }}}
	else if(value.type === TokenType.BACK_REFERENCE) { // {{{
		result += `\\${value.code}`
	} // }}}
	else if(value.type === TokenType.BACKSPACE) { // {{{
		result += '\\b'
	} // }}}
	else if(value.type === TokenType.BEGIN) { // {{{
		result += '^'
	} // }}}
	else if(value.type === TokenType.CAPTURE_GROUP) { // {{{
		result += '('

		result = toString(value.body, result)

		result += ')'
	} // }}}
	else if(value.type === TokenType.CARRIAGE_RETURN) { // {{{
		result += '\\r'
	} // }}}
	else if(value.type === TokenType.CHARSET) { // {{{
		result += '['

		if(value.negated) {
			result += '^'
		}

		for(const val of value.body) {
			result = toString(val, result)
		}

		result += ']'
	} // }}}
	else if(value.type === TokenType.CONTROL) { // {{{
		result += `\\c${value.code}`
	} // }}}
	else if(value.type === TokenType.DIGIT) { // {{{
		result += `\\d`
	} // }}}
	else if(value.type === TokenType.END) { // {{{
		result += '$'
	} // }}}
	else if(value.type === TokenType.ESCAPE) { // {{{
		result += `\\${value.code}`
	} // }}}
	else if(value.type === TokenType.FORM_FEED) { // {{{
		result += '\\f'
	} // }}}
	else if(value.type === TokenType.HEX) { // {{{
		result += `\\x${value.code}`
	} // }}}
	else if(value.type === TokenType.LINE_FEED) { // {{{
		result += `\\n`
	} // }}}
	else if(value.type === TokenType.LITERAL) { // {{{
		result += value.text
	} // }}}
	else if(value.type === TokenType.MATCH) { // {{{
		for(const val of value.body) {
			result = toString(val, result)
		}
	} // }}}
	else if(value.type === TokenType.MODIFIED_GROUP) { // {{{
		result += '(?'

		result += value.modifiers.positive.join('')

		if(value.modifiers.negative.length) {
			result += `-${value.modifiers.negative.join('')}`
		}

		result += ':'

		result = toString(value.body, result)

		result += ')'
	} // }}}
	else if(value.type === TokenType.MODIFIER) { // {{{
		result += '(?'

		result += value.positive.join('')

		if(value.negative.length) {
			result += `-${value.negative.join('')}`
		}

		result += ')'
	} // }}}
	else if(value.type === TokenType.NAMED_BACK_REFERENCE) { // {{{
		result += `\\k<${value.name}>`
	} // }}}
	else if(value.type === TokenType.NAMED_GROUP) { // {{{
		result += `(?<${value.name}>`

		result = toString(value.body, result)

		result += ')'
	} // }}}
	else if(value.type === TokenType.NEGATIVE_LOOKAHEAD) { // {{{
		result += '(?!'

		result = toString(value.body, result)

		result += ')'
	} // }}}
	else if(value.type === TokenType.NEGATIVE_LOOKBEHIND) { // {{{
		result += '(?<!'

		result = toString(value.body, result)

		result += ')'
	} // }}}
	else if(value.type === TokenType.NON_CAPTURE_GROUP) { // {{{
		result += '(?:'

		result = toString(value.body, result)

		result += ')'
	} // }}}
	else if(value.type === TokenType.NON_DIGIT) { // {{{
		result += '\\D'
	} // }}}
	else if(value.type === TokenType.NON_UNICODE_PROPERTY) { // {{{
		result += `\\P{${value.property}}`
	} // }}}
	else if(value.type === TokenType.NON_WHITE_SPACE) { // {{{
		result += '\\S'
	} // }}}
	else if(value.type === TokenType.NON_WORD) { // {{{
		result += '\\W'
	} // }}}
	else if(value.type === TokenType.NON_WORD_BOUNDARY) { // {{{
		result += '\\B'
	} // }}}
	else if(value.type === TokenType.NUL) { // {{{
		result += '\\0'
	} // }}}
	else if(value.type === TokenType.OCTAL) { // {{{
		result += `\\0${value.code}`
	} // }}}
	else if(value.type === TokenType.PATTERN) { // {{{
		result += '/'
		result = toString(value.body, result)
		result += '/'

		if(value.modifiers) {
			result += value.modifiers.positive.join('')
		}
	} // }}}
	else if(value.type === TokenType.POSITIVE_LOOKAHEAD) { // {{{
		result += '(?='

		result = toString(value.body, result)

		result += ')'
	} // }}}
	else if(value.type === TokenType.POSITIVE_LOOKBEHIND) { // {{{
		result += '(?<='

		result = toString(value.body, result)

		result += ')'
	} // }}}
	else if(value.type === TokenType.QUANTIFIED) { // {{{
		result = toString(value.body, result)
		result = toString(value.quantifier, result)
	} // }}}
	else if(value.type === TokenType.QUANTIFIER) { // {{{
		if(value.max === Infinity) {
			if(value.min === 0) {
				result += '*'
			}
			else if(value.min === 1) {
				result += '+'
			}
			else {
				result += `{${value.min},}`
			}
		}
		else if(value.min === 0 && value.max === 1) {
			result += '?'
		}
		else if(value.min === value.max) {
			result += `{${value.min}}`
		}
		else {
			result += `{${value.min},${value.max}}`
		}
	} // }}}
	else if(value.type === TokenType.RANGE) { // {{{
		result = toString(value.begin, result)
		result += '-'
		result = toString(value.end, result)
	} // }}}
	else if(value.type === TokenType.TAB) { // {{{
		result += '\\t'
	} // }}}
	else if(value.type === TokenType.UNICODE) { // {{{
		result += `\\u{${value.code}}`
	} // }}}
	else if(value.type === TokenType.UNICODE_PROPERTY) { // {{{
		result += `\\p{${value.property}}`
	} // }}}
	else if(value.type === TokenType.UTF16) { // {{{
		result += `\\u${value.code}`
	} // }}}
	else if(value.type === TokenType.VERTICAL_TAB) { // {{{
		result += '\\v'
	} // }}}
	else if(value.type === TokenType.WHITE_SPACE) { // {{{
		result += '\\s'
	} // }}}
	else if(value.type === TokenType.WORD) { // {{{
		result += `\\w`
	} // }}}
	else if(value.type === TokenType.WORD_BOUNDARY) { // {{{
		result += `\\b`
	} // }}}

	return result
}

module.exports = {
	stringify
}


/***/ }),

/***/ 784:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const { parse } = __nccwpck_require__(51)

function transform(tokens, callback) {
	if(typeof callback === 'function') {
		transformFunc(tokens, null, null, callback)
	}
	else if(callback) {
		transformMap(tokens, callback)
	}
}

function transformFunc(tokens, parent, key, callback) {
	if(Array.isArray(tokens)) {
		let i = -1
		let notSkipped = true

		const that = {
			remove() {
				tokens.splice(i, 1)

				--i

				notSkipped = false
			},
			replace(token, transform) {
				if(typeof token === 'string') {
					token = parse(token).body
				}

				if(Array.isArray(token)) {
					tokens.splice(i, 1, ...token)
				}
				else {
					tokens.splice(i, 1, token)
				}

				if(transform) {
					--i
				}
				else if(Array.isArray(token)) {
					i += token.length - 1
				}

				notSkipped = false
			},
			transform(tokens, parent, key) {
				transformFunc(tokens, parent, key, callback)

				notSkipped = false
			}
		}

		while(++i < tokens.length) {
			const token = tokens[i]

			callback.call(that, token, parent, key, i)

			if(notSkipped) {
				token.body && transformFunc(token.body, token, 'body', callback)
			}
			else {
				notSkipped = true
			}
		}
	}
	else if(parent) {
		let notSkipped = true

		const that = {
			remove() {
				delete parent[key]

				notSkipped = false
			},
			replace(token, transform) {
				if(typeof token === 'string') {
					token = parse(token).body
				}

				parent[key] = token

				if(transform) {
					transformFunc(token, parent, key, callback)
				}

				notSkipped = false
			},
			transform(tokens, parent, key) {
				transformFunc(tokens, parent, key, callback)

				notSkipped = false
			}
		}

		callback.call(that, tokens, parent, key)

		if(notSkipped) {
			tokens.body && transformFunc(tokens.body, tokens, 'body', callback)
		}
		else {
			notSkipped = true
		}
	}
	else {
		callback.call(null, tokens)

		tokens.body && transformFunc(tokens.body, tokens, 'body', callback)
	}
}

function transformMap(tokens, callbackMap) {
	transformFunc(tokens, null, null, function(token, parent, key, index) {
		if(callbackMap[token.type]) {
			callbackMap[token.type].call(this, token, parent, key, index)
		}
	})
}

module.exports = {
	transform
}


/***/ }),

/***/ 238:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const { TokenType } = __nccwpck_require__(446)
const { isRegExp } = __nccwpck_require__(95)
const { parse } = __nccwpck_require__(51)
const { stringify } = __nccwpck_require__(221)
const { transform } = __nccwpck_require__(784)

const Flavor = {
	ES2018: 'es2018'
}

const Translators = {
	[Flavor.ES2018]: translateES2018
}

function translate(value, target, toString = true) {
	const translator = Translators[target]
	if(!translator) {
		return value
	}

	let result

	if(Array.isArray(value)) {
		result = []

		for(const token of value) {
			result.push(translator(token))
		}
	}
	else if(isRegExp(value) || typeof value === 'string') {
		result = translator(parse(value))
	}
	else {
		result = translator(value)
	}

	if(toString) {
		return stringify(result)
	}
	else {
		return result
	}
}

function translateES2018(ast) {
	let caseless = false
	let inCharset = false
	let sets = null

	transform(ast, {
		[TokenType.CHARSET](token) {
			inCharset = true
			sets = {}

			this.transform(token.body, token, 'body')

			inCharset = false
		},
		[TokenType.LITERAL](token) {
			if(caseless) {
				let text = '';
				let upper, lower, upperLower

				for(const c of token.text.split('')) {
					upper = c.toUpperCase()
					lower = c.toLowerCase()

					if(upper === lower) {
						text += upper
					}
					else {
						upperLower = `${upper}${lower}`

						if(inCharset) {
							if(!sets[upperLower]) {
								sets[upperLower] = true

								text += upperLower
							}
						}
						else {
							text += `[${upperLower}]`
						}
					}
				}

				if(token.text !== text) {
					this.replace(text)
				}
			}
		},
		[TokenType.MODIFIED_GROUP](token) {
			if(token.modifiers.positive.includes('i')) {
				caseless = true
			}
			if(token.modifiers.negative.includes('i')) {
				caseless = false
			}

			this.replace({
				type: TokenType.NON_CAPTURE_GROUP,
				body: token.body
			}, true)
		},
		[TokenType.MODIFIER](token) {
			if(token.positive.includes('i')) {
				caseless = true
			}
			if(token.negative.includes('i')) {
				caseless = false
			}

			this.remove()
		},
		[TokenType.RANGE](token) {
			if(caseless) {
				let beginUpper, beginLower
				if(token.begin.type === TokenType.LITERAL) {
					beginUpper = token.begin.text.toUpperCase()
					beginLower = token.begin.text.toLowerCase()
				}

				let endUpper, endLower
				if(token.end.type === TokenType.LITERAL) {
					endUpper = token.end.text.toUpperCase()
					endLower = token.end.text.toLowerCase()
				}

				if(beginUpper && endUpper && beginUpper !== beginLower && (beginUpper.charCodeAt(0) - endUpper.charCodeAt(0)) === (beginLower.charCodeAt(0) - endLower.charCodeAt(0))) {
					const range = `${beginUpper}-${endUpper}${beginLower}-${endLower}`

					if(sets[range]) {
						this.remove()
					}
					else {
						sets[range] = true

						this.replace(range)
					}
				}
			}
		}
	})

	return ast
}

module.exports = {
	Flavor,
	translate
}


/***/ }),

/***/ 446:
/***/ ((module) => {

const TokenType = {
	ALTERNATE: 'alternate',
	ANY: 'any',
	BACK_REFERENCE: 'back-reference',
	BACKSPACE: 'backspace',
	BEGIN: 'begin',
	CAPTURE_GROUP: 'capture-group',
	CARRIAGE_RETURN: 'carriage-return',
	CHARSET: 'charset',
	CONTROL: 'control',
	DIGIT: 'digit',
	END: 'end',
	ESCAPE: 'escape',
	FORM_FEED: 'form-feed',
	HEX: 'hex',
	LINE_FEED: 'line-feed',
	LITERAL: 'literal',
	MATCH: 'match',
	MODIFIED_GROUP: 'modified-group',
	MODIFIER: 'modifier',
	NAMED_BACK_REFERENCE: 'named-back-reference',
	NAMED_GROUP: 'named-group',
	NEGATIVE_LOOKAHEAD: 'negative-lookahead',
	NEGATIVE_LOOKBEHIND: 'negative-lookbehind',
	NON_CAPTURE_GROUP: 'non-capture-group',
	NON_DIGIT: 'non-digit',
	NON_UNICODE_PROPERTY: 'non-unicode-property',
	NON_WHITE_SPACE: 'non-white-space',
	NON_WORD: 'non-word',
	NON_WORD_BOUNDARY: 'non-word-boundary',
	NUL: 'nul',
	OCTAL: 'octal',
	PATTERN: 'pattern',
	POSITIVE_LOOKAHEAD: 'positive-lookahead',
	POSITIVE_LOOKBEHIND: 'positive-lookbehind',
	QUANTIFIED: 'quantified',
	QUANTIFIER: 'quantifier',
	RANGE: 'range',
	TAB: 'tab',
	UNICODE: 'unicode',
	UNICODE_PROPERTY: 'unicode-property',
	UTF16: 'utf-16',
	VERTICAL_TAB: 'vertical-tab',
	WHITE_SPACE: 'white-space',
	WORD: 'word',
	WORD_BOUNDARY: 'word-boundary'
}

module.exports = {
	TokenType
}


/***/ }),

/***/ 451:
/***/ ((module) => {

function visit(tokens, callback) {
	if(typeof callback === 'function') {
		visitFunc(tokens, callback)
	}
	else if(callback) {
		visitMap(tokens, callback)
	}
}

function visitFunc(tokens, callback) {
	if(Array.isArray(tokens)) {
		for (const token of tokens) {
			callback(token)

			if (token.body) {
				visitFunc(token.body, callback)
			}
		}
	}
	else if(tokens) {
		callback(tokens)

		if (tokens.body) {
			visitFunc(tokens.body, callback)
		}
	}
}

function visitMap(tokens, callbackMap) {
	visitFunc(tokens, (token) => {
		if(callbackMap[token.type]) {
			callbackMap[token.type](token)
		}
	})
}

module.exports = {
	visit
}


/***/ }),

/***/ 380:
/***/ ((module) => {

"use strict";

module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    if(a===b) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}


/***/ }),

/***/ 489:
/***/ ((module) => {

const isWindows = typeof process === 'object' &&
  process &&
  process.platform === 'win32'
module.exports = isWindows ? { sep: '\\' } : { sep: '/' }


/***/ }),

/***/ 772:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const minimatch = module.exports = (p, pattern, options = {}) => {
  assertValidPattern(pattern)

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  return new Minimatch(pattern, options).match(p)
}

module.exports = minimatch

const path = __nccwpck_require__(489)
minimatch.sep = path.sep

const GLOBSTAR = Symbol('globstar **')
minimatch.GLOBSTAR = GLOBSTAR
const expand = __nccwpck_require__(783)

const plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
const qmark = '[^/]'

// * => any number of characters
const star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
const twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
const twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// "abc" -> { a:true, b:true, c:true }
const charSet = s => s.split('').reduce((set, c) => {
  set[c] = true
  return set
}, {})

// characters that need to be escaped in RegExp.
const reSpecials = charSet('().*{}+?[]^$\\!')

// characters that indicate we have to add the pattern start
const addPatternStartSet = charSet('[.(')

// normalizes slashes.
const slashSplit = /\/+/

minimatch.filter = (pattern, options = {}) =>
  (p, i, list) => minimatch(p, pattern, options)

const ext = (a, b = {}) => {
  const t = {}
  Object.keys(a).forEach(k => t[k] = a[k])
  Object.keys(b).forEach(k => t[k] = b[k])
  return t
}

minimatch.defaults = def => {
  if (!def || typeof def !== 'object' || !Object.keys(def).length) {
    return minimatch
  }

  const orig = minimatch

  const m = (p, pattern, options) => orig(p, pattern, ext(def, options))
  m.Minimatch = class Minimatch extends orig.Minimatch {
    constructor (pattern, options) {
      super(pattern, ext(def, options))
    }
  }
  m.Minimatch.defaults = options => orig.defaults(ext(def, options)).Minimatch
  m.filter = (pattern, options) => orig.filter(pattern, ext(def, options))
  m.defaults = options => orig.defaults(ext(def, options))
  m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options))
  m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options))
  m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options))

  return m
}





// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = (pattern, options) => braceExpand(pattern, options)

const braceExpand = (pattern, options = {}) => {
  assertValidPattern(pattern)

  // Thanks to Yeting Li <https://github.com/yetingli> for
  // improving this regexp to avoid a ReDOS vulnerability.
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

const MAX_PATTERN_LENGTH = 1024 * 64
const assertValidPattern = pattern => {
  if (typeof pattern !== 'string') {
    throw new TypeError('invalid pattern')
  }

  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError('pattern is too long')
  }
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
const SUBPARSE = Symbol('subparse')

minimatch.makeRe = (pattern, options) =>
  new Minimatch(pattern, options || {}).makeRe()

minimatch.match = (list, pattern, options = {}) => {
  const mm = new Minimatch(pattern, options)
  list = list.filter(f => mm.match(f))
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

// replace stuff like \* with *
const globUnescape = s => s.replace(/\\(.)/g, '$1')
const charUnescape = s => s.replace(/\\([^-\]])/g, '$1')
const regExpEscape = s => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
const braExpEscape = s => s.replace(/[[\]\\]/g, '\\$&')

class Minimatch {
  constructor (pattern, options) {
    assertValidPattern(pattern)

    if (!options) options = {}

    this.options = options
    this.set = []
    this.pattern = pattern
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape ||
      options.allowWindowsEscape === false
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, '/')
    }
    this.regexp = null
    this.negate = false
    this.comment = false
    this.empty = false
    this.partial = !!options.partial

    // make the set of regexps etc.
    this.make()
  }

  debug () {}

  make () {
    const pattern = this.pattern
    const options = this.options

    // empty patterns and comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === '#') {
      this.comment = true
      return
    }
    if (!pattern) {
      this.empty = true
      return
    }

    // step 1: figure out negation, etc.
    this.parseNegate()

    // step 2: expand braces
    let set = this.globSet = this.braceExpand()

    if (options.debug) this.debug = (...args) => console.error(...args)

    this.debug(this.pattern, set)

    // step 3: now we have a set, so turn each one into a series of path-portion
    // matching patterns.
    // These will be regexps, except in the case of "**", which is
    // set to the GLOBSTAR object for globstar behavior,
    // and will not contain any / characters
    set = this.globParts = set.map(s => s.split(slashSplit))

    this.debug(this.pattern, set)

    // glob --> regexps
    set = set.map((s, si, set) => s.map(this.parse, this))

    this.debug(this.pattern, set)

    // filter out everything that didn't compile properly.
    set = set.filter(s => s.indexOf(false) === -1)

    this.debug(this.pattern, set)

    this.set = set
  }

  parseNegate () {
    if (this.options.nonegate) return

    const pattern = this.pattern
    let negate = false
    let negateOffset = 0

    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {
      negate = !negate
      negateOffset++
    }

    if (negateOffset) this.pattern = pattern.slice(negateOffset)
    this.negate = negate
  }

  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne (file, pattern, partial) {
    var options = this.options

    this.debug('matchOne',
      { 'this': this, file: file, pattern: pattern })

    this.debug('matchOne', file.length, pattern.length)

    for (var fi = 0,
        pi = 0,
        fl = file.length,
        pl = pattern.length
        ; (fi < fl) && (pi < pl)
        ; fi++, pi++) {
      this.debug('matchOne loop')
      var p = pattern[pi]
      var f = file[fi]

      this.debug(pattern, p, f)

      // should be impossible.
      // some invalid regexp stuff in the set.
      /* istanbul ignore if */
      if (p === false) return false

      if (p === GLOBSTAR) {
        this.debug('GLOBSTAR', [pattern, p, f])

        // "**"
        // a/**/b/**/c would match the following:
        // a/b/x/y/z/c
        // a/x/y/z/b/c
        // a/b/x/b/x/c
        // a/b/c
        // To do this, take the rest of the pattern after
        // the **, and see if it would match the file remainder.
        // If so, return success.
        // If not, the ** "swallows" a segment, and try again.
        // This is recursively awful.
        //
        // a/**/b/**/c matching a/b/x/y/z/c
        // - a matches a
        // - doublestar
        //   - matchOne(b/x/y/z/c, b/**/c)
        //     - b matches b
        //     - doublestar
        //       - matchOne(x/y/z/c, c) -> no
        //       - matchOne(y/z/c, c) -> no
        //       - matchOne(z/c, c) -> no
        //       - matchOne(c, c) yes, hit
        var fr = fi
        var pr = pi + 1
        if (pr === pl) {
          this.debug('** at the end')
          // a ** at the end will just swallow the rest.
          // We have found a match.
          // however, it will not swallow /.x, unless
          // options.dot is set.
          // . and .. are *never* matched by **, for explosively
          // exponential reasons.
          for (; fi < fl; fi++) {
            if (file[fi] === '.' || file[fi] === '..' ||
              (!options.dot && file[fi].charAt(0) === '.')) return false
          }
          return true
        }

        // ok, let's see if we can swallow whatever we can.
        while (fr < fl) {
          var swallowee = file[fr]

          this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

          // XXX remove this slice.  Just pass the start index.
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug('globstar found match!', fr, fl, swallowee)
            // found a match.
            return true
          } else {
            // can't swallow "." or ".." ever.
            // can only swallow ".foo" when explicitly asked.
            if (swallowee === '.' || swallowee === '..' ||
              (!options.dot && swallowee.charAt(0) === '.')) {
              this.debug('dot detected!', file, fr, pattern, pr)
              break
            }

            // ** swallows a segment, and continue.
            this.debug('globstar swallow a segment, and continue')
            fr++
          }
        }

        // no match was found.
        // However, in partial mode, we can't say this is necessarily over.
        // If there's more *pattern* left, then
        /* istanbul ignore if */
        if (partial) {
          // ran out of file
          this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
          if (fr === fl) return true
        }
        return false
      }

      // something other than **
      // non-magic patterns just have to match exactly
      // patterns with magic have been turned into regexps.
      var hit
      if (typeof p === 'string') {
        hit = f === p
        this.debug('string match', p, f, hit)
      } else {
        hit = f.match(p)
        this.debug('pattern match', p, f, hit)
      }

      if (!hit) return false
    }

    // Note: ending in / means that we'll get a final ""
    // at the end of the pattern.  This can only match a
    // corresponding "" at the end of the file.
    // If the file ends in /, then it can only match a
    // a pattern that ends in /, unless the pattern just
    // doesn't have any more for it. But, a/b/ should *not*
    // match "a/b/*", even though "" matches against the
    // [^/]*? pattern, except in partial mode, where it might
    // simply not be reached yet.
    // However, a/b/ should still satisfy a/*

    // now either we fell off the end of the pattern, or we're done.
    if (fi === fl && pi === pl) {
      // ran out of pattern and filename at the same time.
      // an exact hit!
      return true
    } else if (fi === fl) {
      // ran out of file, but still had pattern left.
      // this is ok if we're doing the match as part of
      // a glob fs traversal.
      return partial
    } else /* istanbul ignore else */ if (pi === pl) {
      // ran out of pattern, still have file left.
      // this is only acceptable if we're on the very last
      // empty segment of a file with a trailing slash.
      // a/* should match a/b/
      return (fi === fl - 1) && (file[fi] === '')
    }

    // should be unreachable.
    /* istanbul ignore next */
    throw new Error('wtf?')
  }

  braceExpand () {
    return braceExpand(this.pattern, this.options)
  }

  parse (pattern, isSub) {
    assertValidPattern(pattern)

    const options = this.options

    // shortcuts
    if (pattern === '**') {
      if (!options.noglobstar)
        return GLOBSTAR
      else
        pattern = '*'
    }
    if (pattern === '') return ''

    let re = ''
    let hasMagic = false
    let escaping = false
    // ? => one single character
    const patternListStack = []
    const negativeLists = []
    let stateChar
    let inClass = false
    let reClassStart = -1
    let classStart = -1
    let cs
    let pl
    let sp
    // . and .. never match anything that doesn't start with .,
    // even when options.dot is set.  However, if the pattern
    // starts with ., then traversal patterns can match.
    let dotTravAllowed = pattern.charAt(0) === '.'
    let dotFileAllowed = options.dot || dotTravAllowed
    const patternStart = () =>
      dotTravAllowed
        ? ''
        : dotFileAllowed
        ? '(?!(?:^|\\/)\\.{1,2}(?:$|\\/))'
        : '(?!\\.)'
    const subPatternStart = (p) =>
      p.charAt(0) === '.'
        ? ''
        : options.dot
        ? '(?!(?:^|\\/)\\.{1,2}(?:$|\\/))'
        : '(?!\\.)'


    const clearStateChar = () => {
      if (stateChar) {
        // we had some state-tracking character
        // that wasn't consumed by this pass.
        switch (stateChar) {
          case '*':
            re += star
            hasMagic = true
          break
          case '?':
            re += qmark
            hasMagic = true
          break
          default:
            re += '\\' + stateChar
          break
        }
        this.debug('clearStateChar %j %j', stateChar, re)
        stateChar = false
      }
    }

    for (let i = 0, c; (i < pattern.length) && (c = pattern.charAt(i)); i++) {
      this.debug('%s\t%s %s %j', pattern, i, re, c)

      // skip over any that are escaped.
      if (escaping) {
        /* istanbul ignore next - completely not allowed, even escaped. */
        if (c === '/') {
          return false
        }

        if (reSpecials[c]) {
          re += '\\'
        }
        re += c
        escaping = false
        continue
      }

      switch (c) {
        /* istanbul ignore next */
        case '/': {
          // Should already be path-split by now.
          return false
        }

        case '\\':
          if (inClass && pattern.charAt(i + 1) === '-') {
            re += c
            continue
          }

          clearStateChar()
          escaping = true
        continue

        // the various stateChar values
        // for the "extglob" stuff.
        case '?':
        case '*':
        case '+':
        case '@':
        case '!':
          this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

          // all of those are literals inside a class, except that
          // the glob [!a] means [^a] in regexp
          if (inClass) {
            this.debug('  in class')
            if (c === '!' && i === classStart + 1) c = '^'
            re += c
            continue
          }

          // if we already have a stateChar, then it means
          // that there was something like ** or +? in there.
          // Handle the stateChar, then proceed with this one.
          this.debug('call clearStateChar %j', stateChar)
          clearStateChar()
          stateChar = c
          // if extglob is disabled, then +(asdf|foo) isn't a thing.
          // just clear the statechar *now*, rather than even diving into
          // the patternList stuff.
          if (options.noext) clearStateChar()
        continue

        case '(': {
          if (inClass) {
            re += '('
            continue
          }

          if (!stateChar) {
            re += '\\('
            continue
          }

          const plEntry = {
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close,
          }
          this.debug(this.pattern, '\t', plEntry)
          patternListStack.push(plEntry)
          // negation is (?:(?!(?:js)(?:<rest>))[^/]*)
          re += plEntry.open
          // next entry starts with a dot maybe?
          if (plEntry.start === 0 && plEntry.type !== '!') {
            dotTravAllowed = true
            re += subPatternStart(pattern.slice(i + 1))
          }
          this.debug('plType %j %j', stateChar, re)
          stateChar = false
          continue
        }

        case ')': {
          const plEntry = patternListStack[patternListStack.length - 1]
          if (inClass || !plEntry) {
            re += '\\)'
            continue
          }
          patternListStack.pop()

          // closing an extglob
          clearStateChar()
          hasMagic = true
          pl = plEntry
          // negation is (?:(?!js)[^/]*)
          // The others are (?:<pattern>)<type>
          re += pl.close
          if (pl.type === '!') {
            negativeLists.push(Object.assign(pl, { reEnd: re.length }))
          }
          continue
        }

        case '|': {
          const plEntry = patternListStack[patternListStack.length - 1]
          if (inClass || !plEntry) {
            re += '\\|'
            continue
          }

          clearStateChar()
          re += '|'
          // next subpattern can start with a dot?
          if (plEntry.start === 0 && plEntry.type !== '!') {
            dotTravAllowed = true
            re += subPatternStart(pattern.slice(i + 1))
          }
          continue
        }

        // these are mostly the same in regexp and glob
        case '[':
          // swallow any state-tracking char before the [
          clearStateChar()

          if (inClass) {
            re += '\\' + c
            continue
          }

          inClass = true
          classStart = i
          reClassStart = re.length
          re += c
        continue

        case ']':
          //  a right bracket shall lose its special
          //  meaning and represent itself in
          //  a bracket expression if it occurs
          //  first in the list.  -- POSIX.2 2.8.3.2
          if (i === classStart + 1 || !inClass) {
            re += '\\' + c
            continue
          }

          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          cs = pattern.substring(classStart + 1, i)
          try {
            RegExp('[' + braExpEscape(charUnescape(cs)) + ']')
            // looks good, finish up the class.
            re += c
          } catch (er) {
            // out of order ranges in JS are errors, but in glob syntax,
            // they're just a range that matches nothing.
            re = re.substring(0, reClassStart) + '(?:$.)' // match nothing ever
          }
          hasMagic = true
          inClass = false
        continue

        default:
          // swallow any state char that wasn't consumed
          clearStateChar()

          if (reSpecials[c] && !(c === '^' && inClass)) {
            re += '\\'
          }

          re += c
          break

      } // switch
    } // for

    // handle the case where we left a class open.
    // "[abc" is valid, equivalent to "\[abc"
    if (inClass) {
      // split where the last [ was, and escape it
      // this is a huge pita.  We now have to re-walk
      // the contents of the would-be class to re-translate
      // any characters that were passed through as-is
      cs = pattern.slice(classStart + 1)
      sp = this.parse(cs, SUBPARSE)
      re = re.substring(0, reClassStart) + '\\[' + sp[0]
      hasMagic = hasMagic || sp[1]
    }

    // handle the case where we had a +( thing at the *end*
    // of the pattern.
    // each pattern list stack adds 3 chars, and we need to go through
    // and escape any | chars that were passed through as-is for the regexp.
    // Go through and escape them, taking care not to double-escape any
    // | chars that were already escaped.
    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      let tail
      tail = re.slice(pl.reStart + pl.open.length)
      this.debug('setting tail', re, pl)
      // maybe some even number of \, then maybe 1 \, followed by a |
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) => {
        /* istanbul ignore else - should already be done */
        if (!$2) {
          // the | isn't already escaped, so escape it.
          $2 = '\\'
        }

        // need to escape all those slashes *again*, without escaping the
        // one that we need for escaping the | character.  As it works out,
        // escaping an even number of slashes can be done by simply repeating
        // it exactly after itself.  That's why this trick works.
        //
        // I am sorry that you have to see this.
        return $1 + $1 + $2 + '|'
      })

      this.debug('tail=%j\n   %s', tail, tail, pl, re)
      const t = pl.type === '*' ? star
        : pl.type === '?' ? qmark
        : '\\' + pl.type

      hasMagic = true
      re = re.slice(0, pl.reStart) + t + '\\(' + tail
    }

    // handle trailing things that only matter at the very end.
    clearStateChar()
    if (escaping) {
      // trailing \\
      re += '\\\\'
    }

    // only need to apply the nodot start if the re starts with
    // something that could conceivably capture a dot
    const addPatternStart = addPatternStartSet[re.charAt(0)]

    // Hack to work around lack of negative lookbehind in JS
    // A pattern like: *.!(x).!(y|z) needs to ensure that a name
    // like 'a.xyz.yz' doesn't match.  So, the first negative
    // lookahead, has to look ALL the way ahead, to the end of
    // the pattern.
    for (let n = negativeLists.length - 1; n > -1; n--) {
      const nl = negativeLists[n]

      const nlBefore = re.slice(0, nl.reStart)
      const nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
      let nlAfter = re.slice(nl.reEnd)
      const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter

      // Handle nested stuff like *(*.js|!(*.json)), where open parens
      // mean that we should *not* include the ) in the bit that is considered
      // "after" the negated section.
      const closeParensBefore = nlBefore.split(')').length
      const openParensBefore = nlBefore.split('(').length - closeParensBefore
      let cleanAfter = nlAfter
      for (let i = 0; i < openParensBefore; i++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
      }
      nlAfter = cleanAfter

      const dollar = nlAfter === '' && isSub !== SUBPARSE ? '(?:$|\\/)' : ''

      re = nlBefore + nlFirst + nlAfter + dollar + nlLast
    }

    // if the re is not "" at this point, then we need to make sure
    // it doesn't match against an empty path part.
    // Otherwise a/* will match a/, which it should not.
    if (re !== '' && hasMagic) {
      re = '(?=.)' + re
    }

    if (addPatternStart) {
      re = patternStart() + re
    }

    // parsing just a piece of a larger pattern.
    if (isSub === SUBPARSE) {
      return [re, hasMagic]
    }

    // if it's nocase, and the lcase/uppercase don't match, it's magic
    if (options.nocase && !hasMagic) {
      hasMagic = pattern.toUpperCase() !== pattern.toLowerCase()
    }

    // skip the regexp for non-magical patterns
    // unescape anything in it, though, so that it'll be
    // an exact match against a file etc.
    if (!hasMagic) {
      return globUnescape(pattern)
    }

    const flags = options.nocase ? 'i' : ''
    try {
      return Object.assign(new RegExp('^' + re + '$', flags), {
        _glob: pattern,
        _src: re,
      })
    } catch (er) /* istanbul ignore next - should be impossible */ {
      // If it was an invalid regular expression, then it can't match
      // anything.  This trick looks for a character after the end of
      // the string, which is of course impossible, except in multi-line
      // mode, but it's not a /m regex.
      return new RegExp('$.')
    }
  }

  makeRe () {
    if (this.regexp || this.regexp === false) return this.regexp

    // at this point, this.set is a 2d array of partial
    // pattern strings, or "**".
    //
    // It's better to use .match().  This function shouldn't
    // be used, really, but it's pretty convenient sometimes,
    // when you just want to work with a regex.
    const set = this.set

    if (!set.length) {
      this.regexp = false
      return this.regexp
    }
    const options = this.options

    const twoStar = options.noglobstar ? star
      : options.dot ? twoStarDot
      : twoStarNoDot
    const flags = options.nocase ? 'i' : ''

    // coalesce globstars and regexpify non-globstar patterns
    // if it's the only item, then we just do one twoStar
    // if it's the first, and there are more, prepend (\/|twoStar\/)? to next
    // if it's the last, append (\/twoStar|) to previous
    // if it's in the middle, append (\/|\/twoStar\/) to previous
    // then filter out GLOBSTAR symbols
    let re = set.map(pattern => {
      pattern = pattern.map(p =>
        typeof p === 'string' ? regExpEscape(p)
        : p === GLOBSTAR ? GLOBSTAR
        : p._src
      ).reduce((set, p) => {
        if (!(set[set.length - 1] === GLOBSTAR && p === GLOBSTAR)) {
          set.push(p)
        }
        return set
      }, [])
      pattern.forEach((p, i) => {
        if (p !== GLOBSTAR || pattern[i-1] === GLOBSTAR) {
          return
        }
        if (i === 0) {
          if (pattern.length > 1) {
            pattern[i+1] = '(?:\\\/|' + twoStar + '\\\/)?' + pattern[i+1]
          } else {
            pattern[i] = twoStar
          }
        } else if (i === pattern.length - 1) {
          pattern[i-1] += '(?:\\\/|' + twoStar + ')?'
        } else {
          pattern[i-1] += '(?:\\\/|\\\/' + twoStar + '\\\/)' + pattern[i+1]
          pattern[i+1] = GLOBSTAR
        }
      })
      return pattern.filter(p => p !== GLOBSTAR).join('/')
    }).join('|')

    // must match entire pattern
    // ending in a * or ** will make it less strict.
    re = '^(?:' + re + ')$'

    // can match anything, as long as it's not this.
    if (this.negate) re = '^(?!' + re + ').*$'

    try {
      this.regexp = new RegExp(re, flags)
    } catch (ex) /* istanbul ignore next - should be impossible */ {
      this.regexp = false
    }
    return this.regexp
  }

  match (f, partial = this.partial) {
    this.debug('match', f, this.pattern)
    // short-circuit in the case of busted things.
    // comments, etc.
    if (this.comment) return false
    if (this.empty) return f === ''

    if (f === '/' && partial) return true

    const options = this.options

    // windows: need to use /, not \
    if (path.sep !== '/') {
      f = f.split(path.sep).join('/')
    }

    // treat the test path as a set of pathparts.
    f = f.split(slashSplit)
    this.debug(this.pattern, 'split', f)

    // just ONE of the pattern sets in this.set needs to match
    // in order for it to be valid.  If negating, then just one
    // match means that we have failed.
    // Either way, return on the first hit.

    const set = this.set
    this.debug(this.pattern, 'set', set)

    // Find the basename of the path by looking for the last non-empty segment
    let filename
    for (let i = f.length - 1; i >= 0; i--) {
      filename = f[i]
      if (filename) break
    }

    for (let i = 0; i < set.length; i++) {
      const pattern = set[i]
      let file = f
      if (options.matchBase && pattern.length === 1) {
        file = [filename]
      }
      const hit = this.matchOne(file, pattern, partial)
      if (hit) {
        if (options.flipNegate) return true
        return !this.negate
      }
    }

    // didn't get any hits.  this is success if it's a negative
    // pattern, failure otherwise.
    if (options.flipNegate) return false
    return this.negate
  }

  static defaults (def) {
    return minimatch.defaults(def).Minimatch
  }
}

minimatch.Minimatch = Minimatch


/***/ }),

/***/ 783:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var balanced = __nccwpck_require__(380);

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m) return [str];

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  if (/\$$/.test(m.pre)) {    
    for (var k = 0; k < post.length; k++) {
      var expansion = pre+ '{' + m.body + '}' + post[k];
      expansions.push(expansion);
    }
  } else {
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(',') >= 0;
    if (!isSequence && !isOptions) {
      // {a},b}
      if (m.post.match(/,.*\}/)) {
        str = m.pre + '{' + m.body + escClose + m.post;
        return expand(str);
      }
      return [str];
    }

    var n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);
      if (n.length === 1) {
        // x{{a,b}}y ==> x{a}y x{b}y
        n = expand(n[0], false).map(embrace);
        if (n.length === 1) {
          return post.map(function(p) {
            return m.pre + n[0] + p;
          });
        }
      }
    }

    // at this point, n is the parts, and we know it's not a comma set
    // with a single entry.
    var N;

    if (isSequence) {
      var x = numeric(n[0]);
      var y = numeric(n[1]);
      var width = Math.max(n[0].length, n[1].length)
      var incr = n.length == 3
        ? Math.abs(numeric(n[2]))
        : 1;
      var test = lte;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad = n.some(isPadded);

      N = [];

      for (var i = x; test(i, y); i += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === '\\')
            c = '';
        } else {
          c = String(i);
          if (pad) {
            var need = width - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join('0');
              if (i < 0)
                c = '-' + z + c.slice(1);
              else
                c = z + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = [];

      for (var j = 0; j < n.length; j++) {
        N.push.apply(N, expand(n[j], false));
      }
    }

    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
  }

  return expansions;
}



/***/ }),

/***/ 805:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.nudge = nudge;
const vscode_1 = __importDefault(__nccwpck_require__(603));
async function nudge() {
    await vscode_1.default.commands.executeCommand('editor.action.selectAll');
    await new Promise((resolve) => {
        setTimeout(resolve, 500);
    });
    await vscode_1.default.commands.executeCommand('editor.removeManualFoldingRanges');
}


/***/ }),

/***/ 390:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.activate = activate;
const vscode_1 = __importDefault(__nccwpck_require__(603));
const package_json_1 = __importDefault(__nccwpck_require__(330));
const nudge_js_1 = __nccwpck_require__(805);
const folding_hub_js_1 = __nccwpck_require__(352);
const folding_provider_js_1 = __nccwpck_require__(562);
const route_provider_js_1 = __nccwpck_require__(750);
const disposable_js_1 = __nccwpck_require__(743);
const has_value_js_1 = __nccwpck_require__(9);
const settings_js_1 = __nccwpck_require__(400);
const CONFIG_KEY = 'explicitFolding';
const VERSION_KEY = 'explicitFoldingVersion';
const SCHEMES = ['file', 'untitled', 'vscode-userdata'];
const $disposable = new disposable_js_1.Disposable();
const $documents = [];
const $hub = new folding_hub_js_1.FoldingHub(setupProviders);
let $rules = {};
let $useWildcard = false;
class MainProvider {
    providers = {};
    provideFoldingRanges(document) {
        if (!this.providers[document.languageId]) {
            this.providers[document.languageId] = true;
            const config = vscode_1.default.workspace.getConfiguration(CONFIG_KEY, document);
            const delay = getDelay(config);
            if (delay > 0) {
                setTimeout(() => {
                    this.setup(document);
                }, delay);
            }
            else {
                this.setup(document);
            }
        }
        return [];
    } // }}}
    setup(document) {
        const language = document.languageId;
        const config = vscode_1.default.workspace.getConfiguration(CONFIG_KEY, document);
        const additionalSchemes = config.get('additionalSchemes') ?? [];
        const mainProvider = buildProvider(language, config);
        const perFiles = config.get('perFiles');
        const provider = (0, has_value_js_1.hasValue)(perFiles) ? buildRouter(perFiles, mainProvider, config) : mainProvider;
        for (const scheme of [...SCHEMES, ...additionalSchemes]) {
            const disposable = vscode_1.default.languages.registerFoldingRangeProvider({ language, scheme }, provider);
            $disposable.push(disposable);
        }
        foldDocument(document);
    } // }}}
}
function applyDependency(dependency, language, done, dependencies) {
    if (!done.includes(dependency.language)) {
        done.push(dependency.language);
        if (dependencies[dependency.language]) {
            for (const d of dependencies[dependency.language]) {
                applyDependency(d, dependency.language, done, dependencies);
            }
        }
    }
    $rules[language].splice(dependency.index, 0, ...$rules[dependency.language]);
} // }}}
function applyRules(data, rules) {
    if (Array.isArray(data)) {
        rules.push(...data);
    }
    else if (data) {
        rules.push(data);
    }
} // }}}
function buildDependencies(language, newRules, rules, dependencies) {
    for (const rule of newRules) {
        const depends = rule.include;
        if (Array.isArray(depends)) {
            dependencies[language] ??= [];
            for (const dependency of depends) {
                if (!dependencies[language].some(({ language }) => language === dependency)) {
                    dependencies[language].push({ language: dependency, index: rules.length });
                }
            }
        }
        else if (typeof depends === 'string') {
            dependencies[language] ??= [];
            if (!dependencies[language].some(({ language }) => language === depends)) {
                dependencies[language].push({ language: depends, index: rules.length });
            }
        }
        else {
            rules.push(rule);
        }
    }
    return rules;
} // }}}
function buildProvider(language, config) {
    const debug = config.get('debug') ?? false;
    const channel = (0, settings_js_1.getDebugChannel)(debug);
    return new folding_provider_js_1.FoldingProvider($rules[language], channel, $documents);
} // }}}
function buildRouter(perFiles, mainProvider, config) {
    const debug = config.get('debug') ?? false;
    const channel = (0, settings_js_1.getDebugChannel)(debug);
    return new route_provider_js_1.RouteProvider(perFiles, mainProvider, channel, $documents, $rules);
} // }}}
async function buildRules() {
    $rules = {};
    const languages = await vscode_1.default.languages.getLanguages();
    const config = vscode_1.default.workspace.getConfiguration(CONFIG_KEY, null);
    const debug = config.get('debug') ?? false;
    const channel = (0, settings_js_1.getDebugChannel)(debug);
    const dependencies = {};
    const globalRules = config.get('rules') ?? {};
    for (const key in globalRules) {
        if (key.includes(',')) {
            for (const language of key.split(/\s*,\s*/)) {
                if (!$rules[language]) {
                    if (Array.isArray(globalRules[language])) {
                        $rules[language] = globalRules[language];
                    }
                    else {
                        $rules[language] = [globalRules[language]];
                    }
                }
                applyRules(globalRules[key], $rules[language]);
            }
        }
        else if (Array.isArray(globalRules[key])) {
            $rules[key] = globalRules[key];
        }
        else {
            $rules[key] = [globalRules[key]];
        }
    }
    for (const language of Object.keys($rules).filter((lang) => !languages.includes(lang))) {
        $rules[language] = buildDependencies(language, $rules[language], [], dependencies);
    }
    for (const language of languages) {
        const rules = [];
        const hubRules = $hub.getRules(language);
        if (hubRules) {
            channel?.appendLine(`[register] use external rules for language: ${language}`);
            applyRules(hubRules, rules);
        }
        else {
            const langRules = vscode_1.default.workspace.getConfiguration(CONFIG_KEY, { languageId: language }).get('rules');
            for (const newRules of [langRules, $rules[language]]) {
                if (Array.isArray(newRules)) {
                    buildDependencies(language, newRules, rules, dependencies);
                }
            }
        }
        $rules[language] = rules;
    }
    const done = [];
    for (const [language, depends] of Object.entries(dependencies)) {
        done.push(language);
        for (const dependency of depends.reverse()) {
            applyDependency(dependency, language, done, dependencies);
        }
    }
    if (globalRules['*']) {
        $useWildcard = true;
        for (const language of languages) {
            applyRules(globalRules['*'], $rules[language]);
        }
    }
    else {
        $useWildcard = false;
    }
} // }}}
function foldDocument(document) {
    const config = vscode_1.default.workspace.getConfiguration(CONFIG_KEY, document);
    const autoFold = config.get('autoFold') ?? 'none';
    if (autoFold === 'all') {
        void vscode_1.default.commands.executeCommand('editor.foldAll');
    }
    else if (autoFold === 'comments') {
        void vscode_1.default.commands.executeCommand('editor.foldAllBlockComments');
    }
    else if (autoFold !== 'none') {
        try {
            const level = Number.parseInt(autoFold, 10);
            void vscode_1.default.commands.executeCommand('editor.unfoldAll');
            for (let i = 7; i >= level; --i) {
                void vscode_1.default.commands.executeCommand(`editor.foldLevel${i}`);
            }
        }
        catch {
        }
    }
    if (!$documents.includes(document)) {
        $documents.push(document);
    }
} // }}}
function getDelay(config) {
    return config.get('delay') ?? 0;
} // }}}
async function setupProviders() {
    $disposable.dispose();
    await buildRules();
    const defaultProvider = vscode_1.default.workspace.getConfiguration('editor').get('defaultFoldingRangeProvider') ?? '';
    if (defaultProvider === settings_js_1.EXTENSION_ID) {
        setupProvidersWithoutProxy();
    }
    else {
        setupProvidersWithProxy();
    }
} // }}}
function setupProvidersWithProxy() {
    const provider = new MainProvider();
    if ($useWildcard) {
        const config = vscode_1.default.workspace.getConfiguration(CONFIG_KEY, null);
        const wildcardExclusions = Array.isArray(config.wildcardExclusions) ? config.wildcardExclusions : [];
        if (wildcardExclusions.length > 0) {
            for (const language in $rules) {
                if (!wildcardExclusions.includes(language)) {
                    for (const scheme of SCHEMES) {
                        const disposable = vscode_1.default.languages.registerFoldingRangeProvider({ language, scheme }, provider);
                        $disposable.push(disposable);
                    }
                }
            }
        }
        else {
            for (const scheme of SCHEMES) {
                const disposable = vscode_1.default.languages.registerFoldingRangeProvider({ language: '*', scheme }, provider);
                $disposable.push(disposable);
            }
        }
    }
    else {
        for (const language in $rules) {
            if ($rules[language]) {
                for (const scheme of SCHEMES) {
                    const disposable = vscode_1.default.languages.registerFoldingRangeProvider({ language, scheme }, provider);
                    $disposable.push(disposable);
                }
            }
        }
    }
    (0, settings_js_1.getContext)().subscriptions.push($disposable);
} // }}}
function setupProvidersWithoutProxy() {
    const config = vscode_1.default.workspace.getConfiguration(CONFIG_KEY, null);
    const wildcardExclusions = Array.isArray(config.wildcardExclusions) ? config.wildcardExclusions : [];
    void vscode_1.default.languages.getLanguages().then((languages) => {
        for (const language of languages) {
            if (!wildcardExclusions.includes(language)) {
                const config = vscode_1.default.workspace.getConfiguration(CONFIG_KEY, { languageId: language });
                const mainProvider = buildProvider(language, config);
                const perFiles = config.get('perFiles');
                const provider = (0, has_value_js_1.hasValue)(perFiles) ? buildRouter(perFiles, mainProvider, config) : mainProvider;
                const additionalSchemes = config.get('additionalSchemes') ?? [];
                for (const scheme of [...SCHEMES, ...additionalSchemes]) {
                    const disposable = vscode_1.default.languages.registerFoldingRangeProvider({ language, scheme }, provider);
                    $disposable.push(disposable);
                }
            }
        }
    });
    (0, settings_js_1.getContext)().subscriptions.push($disposable);
} // }}}
function setupAutoFold() {
    let documents = [];
    const disposable = vscode_1.default.window.onDidChangeVisibleTextEditors((editors) => {
        const activeEditor = vscode_1.default.window.activeTextEditor;
        if (editors.length > 0 && activeEditor) {
            const activeDocument = activeEditor.document;
            if (!documents.includes(activeDocument)) {
                foldDocument(activeDocument);
            }
            documents = vscode_1.default.workspace.textDocuments;
        }
    });
    (0, settings_js_1.getContext)().subscriptions.push(disposable);
} // }}}
async function showWhatsNewMessage(version) {
    const actions = [{
            title: 'Homepage',
        }, {
            title: 'Release Notes',
        }];
    const result = await vscode_1.default.window.showInformationMessage(`Explicit Folding has been updated to v${version} — check out what's new!`, ...actions);
    if (result !== null) {
        if (result === actions[0]) {
            await vscode_1.default.commands.executeCommand('vscode.open', vscode_1.default.Uri.parse(`${package_json_1.default.homepage}`));
        }
        else if (result === actions[1]) {
            await vscode_1.default.commands.executeCommand('vscode.open', vscode_1.default.Uri.parse(`${package_json_1.default.homepage}/blob/master/CHANGELOG.md`));
        }
    }
} // }}}
async function activate(context) {
    await (0, settings_js_1.setupSettings)(context);
    const previousVersion = context.globalState.get(VERSION_KEY);
    const currentVersion = package_json_1.default.version;
    const config = vscode_1.default.workspace.getConfiguration(CONFIG_KEY, null);
    if (previousVersion === undefined || currentVersion !== previousVersion) {
        void context.globalState.update(VERSION_KEY, currentVersion);
        const notification = config.get('notification');
        if (previousVersion === undefined) {
            // don't show notification on install
        }
        else if (notification === 'major') {
            if (currentVersion.split('.')[0] > previousVersion.split('.')[0]) {
                void showWhatsNewMessage(currentVersion);
            }
        }
        else if (notification === 'minor') {
            if (currentVersion.split('.')[0] > previousVersion.split('.')[0] || (currentVersion.split('.')[0] === previousVersion.split('.')[0] && currentVersion.split('.')[1] > previousVersion.split('.')[1])) {
                void showWhatsNewMessage(currentVersion);
            }
        }
        else if (notification !== 'none') {
            void showWhatsNewMessage(currentVersion);
        }
    }
    await setupProviders();
    setupAutoFold();
    vscode_1.default.workspace.onDidChangeConfiguration(async (event) => {
        if (event.affectsConfiguration(CONFIG_KEY)) {
            await setupProviders();
            setupAutoFold();
        }
    }, vscode_1.default.commands.registerCommand('explicitFolding.nudge', nudge_js_1.nudge));
    return $hub;
} // }}}


/***/ }),

/***/ 352:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FoldingHub = void 0;
class FoldingHub {
    perLanguages = {};
    setup;
    constructor(setup) {
        this.setup = setup;
    }
    getRules(language) {
        return this.perLanguages[language];
    }
    hasRules(language) {
        return this.perLanguages[language] !== undefined;
    }
    registerFoldingRules(language, rules) {
        this.perLanguages[language] = rules;
        this.setup();
    }
    unregisterFoldingRules(language) {
        this.perLanguages[language] = undefined;
        this.setup();
    }
}
exports.FoldingHub = FoldingHub;


/***/ }),

/***/ 562:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FoldingProvider = void 0;
const path_1 = __nccwpck_require__(928);
const regexp_1 = __nccwpck_require__(712);
const vscode_1 = __nccwpck_require__(603);
var Marker;
(function (Marker) {
    Marker[Marker["BEGIN"] = 0] = "BEGIN";
    Marker[Marker["MIDDLE"] = 1] = "MIDDLE";
    Marker[Marker["END"] = 2] = "END";
    Marker[Marker["DOCSTRING"] = 3] = "DOCSTRING";
    Marker[Marker["SEPARATOR"] = 4] = "SEPARATOR";
    Marker[Marker["WHILE"] = 5] = "WHILE";
})(Marker || (Marker = {}));
const TAB = 9;
const SPACE = 32;
function computeIndentLevel(line, tabSize) {
    let indent = 0;
    let index = 0;
    const length = line.length;
    while (index < length) {
        const chCode = line.codePointAt(index);
        if (chCode === SPACE) {
            indent++;
        }
        else if (chCode === TAB) {
            indent = indent - (indent % tabSize) + tabSize;
        }
        else {
            break;
        }
        index++;
    }
    if (index === length) {
        return -1; // line only consists of whitespace
    }
    return indent;
} // }}}
function id(value) {
    return () => value;
} // }}}
function shouldFoldLastLine(foldLastLine, groupIndex, endGroupCount) {
    return (offset, ...args) => {
        for (let i = groupIndex + 1, l = groupIndex + endGroupCount; i < l; ++i) {
            if (args[i + offset] !== undefined) {
                return foldLastLine[i - groupIndex];
            }
        }
        return foldLastLine[0];
    };
} // }}}
class FoldingProvider {
    autoFoldDocuments;
    debugChannel;
    mainRegex;
    indentation = {
        enabled: false,
        offSide: false,
    };
    rules = [];
    constructor(configuration, debugChannel, documents) {
        this.debugChannel = debugChannel;
        this.autoFoldDocuments = documents;
        const groupContext = { index: 0 };
        let source = '';
        for (const value of configuration) {
            const regexSource = this.addRegex(value, groupContext, true, []);
            if (regexSource.length > 0) {
                if (source.length > 0) {
                    source += '|';
                }
                source += regexSource;
            }
        }
        this.mainRegex = source.length === 0 ? /a^/ : new RegExp(source, 'g');
    } // }}}
    provideFoldingRanges(document) {
        if (this.debugChannel) {
            this.debugChannel.show(true);
            this.debugChannel.appendLine(`[document] lang: ${document.languageId}, fileName: ${(0, path_1.basename)(document.fileName)}`);
            this.debugChannel.appendLine(`[main] regex: ${this.mainRegex.toString()}`);
        }
        const foldingRanges = [];
        const foldLines = [];
        const stack = [];
        const endMatches = {};
        let position = { line: 0, offset: 0 };
        try {
            while (position.line < document.lineCount) {
                position = this.resolveExplicitRange(document, foldingRanges, 'main', this.mainRegex, stack, endMatches, 0, false, position.line, position.offset, foldLines);
            }
            this.doEOF(document, foldingRanges, stack, foldLines);
            if (this.indentation.enabled) {
                this.resolveIndentationRange(document, foldingRanges);
            }
        }
        catch (error) {
            if (this.debugChannel && error) {
                this.debugChannel.appendLine(String(error));
            }
        }
        this.debugChannel?.appendLine(`[document] foldings: ${JSON.stringify(foldingRanges)}`);
        const index = this.autoFoldDocuments.indexOf(document);
        if (index !== -1) {
            this.autoFoldDocuments.splice(index, 1);
            if (foldLines.length > 0) {
                void vscode_1.commands.executeCommand('editor.fold', {
                    levels: 1,
                    selectionLines: foldLines,
                });
            }
        }
        return foldingRanges;
    } // }}}
    addRegex(configuration, groupContext, strict, parents) {
        const ruleIndex = this.rules.length;
        try {
            const bypassProtection = configuration.bypassProtection ?? false;
            let begin;
            if (configuration.beginRegex) {
                begin = new RegExp((0, regexp_1.translate)(configuration.beginRegex, regexp_1.Flavor.ES2018));
                if (configuration.beginRegex === configuration.endRegex) {
                    return this.addDocstringRegex(configuration, ruleIndex, begin, groupContext);
                }
            }
            else if (configuration.begin) {
                begin = new RegExp((0, regexp_1.escape)(configuration.begin));
                if (configuration.begin === configuration.end) {
                    return this.addDocstringRegex(configuration, ruleIndex, begin, groupContext);
                }
            }
            if (configuration.indentation) {
                this.indentation.enabled = configuration.indentation;
                this.indentation.offSide = configuration.offSide ?? false;
                if (begin) {
                    this.indentation.filter = begin;
                }
                this.debugChannel?.appendLine(JSON.stringify(configuration));
                if (Array.isArray(configuration.nested)) {
                    const regexes = configuration.nested.map((config) => this.addRegex(config, groupContext, false, [])).filter((regex) => regex.length > 0);
                    const source = regexes.join('|');
                    this.indentation.nestedRegex = source.length === 0 ? /a^/ : new RegExp(source, 'g');
                }
            }
            else if (begin) {
                let continuation;
                let end;
                let whileRegex;
                if (configuration.endRegex) {
                    end = new RegExp((0, regexp_1.translate)(configuration.endRegex, regexp_1.Flavor.ES2018));
                }
                else if (configuration.end) {
                    end = new RegExp((0, regexp_1.escape)(configuration.end));
                }
                else if (configuration.continuationRegex) {
                    const source = (0, regexp_1.translate)(configuration.continuationRegex, regexp_1.Flavor.ES2018);
                    continuation = new RegExp(`${source}$`);
                }
                else if (configuration.continuation) {
                    continuation = new RegExp(`${(0, regexp_1.escape)(configuration.continuation)}$`);
                }
                else if (configuration.whileRegex) {
                    whileRegex = new RegExp((0, regexp_1.translate)(configuration.whileRegex, regexp_1.Flavor.ES2018));
                }
                else if (configuration.while) {
                    whileRegex = new RegExp((0, regexp_1.escape)(configuration.while));
                }
                if (end) {
                    let middle;
                    if (configuration.middleRegex) {
                        middle = new RegExp((0, regexp_1.translate)(configuration.middleRegex, regexp_1.Flavor.ES2018));
                    }
                    else if (configuration.middle) {
                        middle = new RegExp((0, regexp_1.escape)(configuration.middle));
                    }
                    if (this.isSupportedRegex(bypassProtection, begin, middle, end)) {
                        return this.addBeginEndRegex(configuration, ruleIndex, begin, middle, end, groupContext, strict, parents);
                    }
                }
                else if (continuation) {
                    if (this.isSupportedRegex(bypassProtection, begin, continuation)) {
                        return this.addContinuationRegex(configuration, ruleIndex, begin, continuation, groupContext);
                    }
                }
                else if (whileRegex && this.isSupportedRegex(bypassProtection, begin, whileRegex)) {
                    return this.addBeginWhileRegex(configuration, ruleIndex, begin, whileRegex, groupContext);
                }
            }
            else if (configuration.whileRegex) {
                const whileRegex = new RegExp((0, regexp_1.translate)(configuration.whileRegex, regexp_1.Flavor.ES2018));
                if (this.isSupportedRegex(bypassProtection, whileRegex)) {
                    return this.addWhileRegex(configuration, ruleIndex, whileRegex, groupContext);
                }
            }
            else if (configuration.while) {
                const whileRegex = new RegExp((0, regexp_1.escape)(configuration.while));
                if (this.isSupportedRegex(bypassProtection, whileRegex)) {
                    return this.addWhileRegex(configuration, ruleIndex, whileRegex, groupContext);
                }
            }
            else if (configuration.separatorRegex) {
                const separator = new RegExp((0, regexp_1.translate)(configuration.separatorRegex, regexp_1.Flavor.ES2018));
                if (this.isSupportedRegex(bypassProtection, separator)) {
                    return this.addSeparatorRegex(configuration, ruleIndex, separator, groupContext, strict, parents);
                }
            }
            else if (configuration.separator) {
                const separator = new RegExp((0, regexp_1.escape)(configuration.separator));
                if (this.isSupportedRegex(bypassProtection, separator)) {
                    return this.addSeparatorRegex(configuration, ruleIndex, separator, groupContext, strict, parents);
                }
            }
        }
        catch (error) {
            this.debugChannel?.appendLine(String(error));
        }
        return '';
    } // }}}
    addBeginEndRegex(configuration, ruleIndex, begin, middle, end, groupContext, strict, parents) {
        const rule = {
            index: ruleIndex,
            begin,
            middle,
            end,
            consumeEnd: typeof configuration.consumeEnd === 'boolean' ? id(configuration.consumeEnd) : id(true),
            foldLastLine: typeof configuration.foldLastLine === 'boolean' ? id(configuration.foldLastLine) : id(true),
            foldBeforeFirstLine: typeof configuration.foldBeforeFirstLine === 'boolean' ? configuration.foldBeforeFirstLine : false,
            foldBOF: false,
            foldEOF: configuration.foldEOF ?? false,
            nested: typeof configuration.nested === 'boolean' ? configuration.nested : !Array.isArray(configuration.nested),
            strict: typeof configuration.strict === 'boolean' ? configuration.strict : (configuration.strict === 'never' ? false : strict),
            kind: configuration.kind === 'comment' ? vscode_1.FoldingRangeKind.Comment : vscode_1.FoldingRangeKind.Region,
            autoFold: configuration.autoFold ?? false,
        };
        this.rules.push(rule);
        let source = `(?<_${Marker.BEGIN}_${ruleIndex}>${rule.begin.source})`;
        const groups = this.listCaptureGroups(begin.source);
        const beginGroupCount = 1 + groups.length;
        const middleGroupCount = rule.middle ? 1 + this.getCaptureGroupCount(middle.source) : 0;
        const endGroupCount = 1 + this.getCaptureGroupCount(end.source);
        if (groups.length > 0) {
            let index = groupContext.index + 1;
            const captures = configuration.endRegex.split(/\\(\d+)/g);
            if (captures.length > 0) {
                const last = captures.length - 1;
                let regexSource = '""';
                for (let i = 0; i <= last; i += 2) {
                    if (i === last) {
                        if (captures[i].length > 0) {
                            regexSource += ` + "${(0, regexp_1.escape)(captures[i]).replaceAll('"', '\\"')}"`;
                        }
                    }
                    else {
                        regexSource += ` + "${(0, regexp_1.escape)(captures[i]).replaceAll('"', '\\"')}" + escape(args[${++index} + offset])`;
                    }
                }
                // eslint-disable-next-line no-eval
                rule.endMatcher = eval('(function(){return function(escape, offset, ...args) { return ' + regexSource + ';};})()');
            }
        }
        groupContext.index += beginGroupCount;
        if (Array.isArray(configuration.consumeEnd) && configuration.consumeEnd.length === endGroupCount) {
            const consumeEnd = configuration.consumeEnd;
            const groupIndex = 1 + (rule.nested ? groupContext.index : 0) + middleGroupCount;
            rule.consumeEnd = shouldFoldLastLine(consumeEnd, groupIndex, endGroupCount);
        }
        if (Array.isArray(configuration.foldLastLine) && configuration.foldLastLine.length === endGroupCount) {
            const foldLastLine = configuration.foldLastLine;
            const groupIndex = 1 + (rule.nested ? groupContext.index : 0) + middleGroupCount;
            rule.foldLastLine = shouldFoldLastLine(foldLastLine, groupIndex, endGroupCount);
        }
        if (rule.nested) {
            if (rule.middle) {
                source += `|(?<_${Marker.MIDDLE}_${ruleIndex}>${rule.middle.source})`;
                groupContext.index += middleGroupCount;
            }
            if (!rule.endMatcher) {
                source += `|(?<_${Marker.END}_${ruleIndex}>${rule.end.source})`;
                groupContext.index += endGroupCount;
            }
        }
        else {
            rule.name = configuration.name ?? `loop=${ruleIndex}`;
            if (Array.isArray(configuration.nested)) {
                const strictParent = configuration.strict === 'never' ? false : strict;
                if (!strictParent) {
                    const regexes = configuration.nested.map((config) => this.addRegex(config, groupContext, false, [...parents, ruleIndex])).filter((regex) => regex.length > 0);
                    source += `|${regexes.join('|')}`;
                }
                const subgroupContext = { index: 1 };
                const regexes = configuration.nested.map((config) => this.addRegex(config, subgroupContext, strictParent, [...parents, ruleIndex])).filter((regex) => regex.length > 0);
                let loopSource = '';
                if (rule.middle) {
                    loopSource += `(?<_${Marker.MIDDLE}_${ruleIndex}>${rule.middle.source})`;
                }
                if (!rule.endMatcher) {
                    if (loopSource) {
                        loopSource += '|';
                    }
                    loopSource += `(?<_${Marker.END}_${ruleIndex}>${rule.end.source})`;
                }
                if (loopSource) {
                    loopSource += '|';
                }
                loopSource += regexes.join('|');
                rule.loopRegex = new RegExp(loopSource, 'g');
            }
            else {
                let loopSource = '';
                if (rule.middle) {
                    loopSource += `(?<_${Marker.MIDDLE}_${ruleIndex}>${rule.middle.source})`;
                }
                if (!rule.endMatcher) {
                    if (loopSource) {
                        loopSource += '|';
                    }
                    loopSource += `(?<_${Marker.END}_${ruleIndex}>${rule.end.source})`;
                }
                if (loopSource) {
                    rule.loopRegex = new RegExp(loopSource, 'g');
                }
            }
        }
        return source;
    } // }}}
    addBeginWhileRegex(configuration, ruleIndex, begin, whileRegex, groupContext) {
        groupContext.index += 1 + this.getCaptureGroupCount(begin.source);
        const rule = {
            index: ruleIndex,
            begin,
            while: whileRegex,
            foldLastLine: typeof configuration.foldLastLine === 'boolean' ? id(configuration.foldLastLine) : id(true),
            foldBeforeFirstLine: typeof configuration.foldBeforeFirstLine === 'boolean' ? configuration.foldBeforeFirstLine : false,
            foldBOF: false,
            foldEOF: configuration.foldEOF ?? false,
            nested: false,
            kind: configuration.kind === 'comment' ? vscode_1.FoldingRangeKind.Comment : vscode_1.FoldingRangeKind.Region,
            autoFold: configuration.autoFold ?? false,
        };
        this.rules.push(rule);
        return `(?<_${Marker.BEGIN}_${ruleIndex}>${rule.begin.source})`;
    } // }}}
    addContinuationRegex(configuration, ruleIndex, begin, whileRegex, groupContext) {
        groupContext.index += 1 + this.getCaptureGroupCount(begin.source);
        const rule = {
            index: ruleIndex,
            begin,
            while: whileRegex,
            continuation: true,
            foldLastLine: typeof configuration.foldLastLine === 'boolean' ? id(configuration.foldLastLine) : id(true),
            foldBeforeFirstLine: typeof configuration.foldBeforeFirstLine === 'boolean' ? configuration.foldBeforeFirstLine : false,
            foldBOF: false,
            foldEOF: configuration.foldEOF ?? false,
            nested: false,
            kind: configuration.kind === 'comment' ? vscode_1.FoldingRangeKind.Comment : vscode_1.FoldingRangeKind.Region,
            autoFold: configuration.autoFold ?? false,
        };
        this.rules.push(rule);
        return `(?<_${Marker.BEGIN}_${ruleIndex}>${rule.begin.source})`;
    } // }}}
    addDocstringRegex(configuration, ruleIndex, begin, groupContext) {
        groupContext.index += 1 + this.getCaptureGroupCount(begin.source);
        const rule = {
            index: ruleIndex,
            begin,
            foldLastLine: typeof configuration.foldLastLine === 'boolean' ? id(configuration.foldLastLine) : id(true),
            foldBeforeFirstLine: typeof configuration.foldBeforeFirstLine === 'boolean' ? configuration.foldBeforeFirstLine : false,
            foldBOF: false,
            foldEOF: configuration.foldEOF ?? false,
            nested: typeof configuration.nested === 'boolean' ? configuration.nested : true,
            kind: configuration.kind === 'comment' ? vscode_1.FoldingRangeKind.Comment : vscode_1.FoldingRangeKind.Region,
            autoFold: configuration.autoFold ?? false,
        };
        this.rules.push(rule);
        return `(?<_${Marker.DOCSTRING}_${ruleIndex}>${rule.begin.source})`;
    } // }}}
    addSeparatorRegex(configuration, ruleIndex, separator, groupContext, strict, parents) {
        groupContext.index += 1 + this.getCaptureGroupCount(separator.source);
        const rule = {
            index: ruleIndex,
            begin: separator,
            foldLastLine: id(false),
            foldBeforeFirstLine: false,
            foldBOF: typeof configuration.foldBOF === 'boolean' ? configuration.foldBOF : true,
            foldEOF: typeof configuration.foldEOF === 'boolean' ? configuration.foldEOF : true,
            nested: typeof configuration.nested === 'boolean' ? configuration.nested : true,
            strict: typeof configuration.strict === 'boolean' ? configuration.strict : (configuration.strict === 'never' ? false : strict),
            kind: configuration.kind === 'comment' ? vscode_1.FoldingRangeKind.Comment : vscode_1.FoldingRangeKind.Region,
            autoFold: configuration.autoFold ?? false,
            parents,
        };
        this.rules.push(rule);
        const nested = configuration.descendants ?? (Array.isArray(configuration.nested) ? configuration.nested : null);
        if (nested) {
            const regexes = nested.map((config) => this.addRegex(config, groupContext, configuration.strict === 'never' ? false : strict, [...parents, ruleIndex])).filter((regex) => regex.length > 0);
            return `(?<_${Marker.SEPARATOR}_${ruleIndex}>${rule.begin.source})|${regexes.join('|')}`;
        }
        return `(?<_${Marker.SEPARATOR}_${ruleIndex}>${rule.begin.source})`;
    } // }}}
    addWhileRegex(configuration, ruleIndex, whileRegex, groupContext) {
        groupContext.index += 1 + this.getCaptureGroupCount(whileRegex.source);
        const rule = {
            index: ruleIndex,
            while: whileRegex,
            foldLastLine: typeof configuration.foldLastLine === 'boolean' ? id(configuration.foldLastLine) : id(true),
            foldBeforeFirstLine: typeof configuration.foldBeforeFirstLine === 'boolean' ? configuration.foldBeforeFirstLine : false,
            foldBOF: false,
            foldEOF: configuration.foldEOF ?? false,
            nested: false,
            kind: configuration.kind === 'comment' ? vscode_1.FoldingRangeKind.Comment : vscode_1.FoldingRangeKind.Region,
            autoFold: configuration.autoFold ?? false,
        };
        this.rules.push(rule);
        return `(?<_${Marker.WHILE}_${ruleIndex}>${rule.while.source})`;
    } // }}}
    doEOF(document, foldingRanges, stack, foldLines) {
        const end = document.lineCount;
        while (stack[0]) {
            if (stack[0].rule.foldEOF) {
                const begin = stack[0].line;
                if (end > begin + 1) {
                    this.pushNewRange(stack[0].rule, begin, end - 1, foldingRanges, foldLines);
                }
            }
            stack.shift();
        }
    } // }}}
    doWhile(document, foldingRanges, rule, line, continuation, foldLines) {
        const begin = line;
        while (++line < document.lineCount) {
            const text = document.lineAt(line).text;
            if (!rule.while.test(text)) {
                const end = line - (continuation ? 0 : 1);
                if (rule.foldLastLine()) {
                    if (end > begin) {
                        this.pushNewRange(rule, begin, end, foldingRanges, foldLines);
                    }
                    return { line: end + 1, offset: 0 };
                }
                if (end > begin + 1) {
                    this.pushNewRange(rule, begin, end - 1, foldingRanges, foldLines);
                }
                return { line: end, offset: 0 };
            }
        }
        const end = Math.min(line, document.lineCount - 1);
        if (rule.foldLastLine()) {
            if (end > begin) {
                this.pushNewRange(rule, begin, end, foldingRanges, foldLines);
            }
        }
        else if (end > begin + 1) {
            this.pushNewRange(rule, begin, end - 1, foldingRanges, foldLines);
        }
        return { line, offset: 0 };
    } // }}}
    *findOfRegexp(regex, line, offset) {
        // reset regex
        regex.lastIndex = offset;
        while (true) {
            const match = regex.exec(line);
            if (match?.groups) {
                const index = match.index ?? 0;
                if (index < offset) {
                    continue;
                }
                const nextOffset = index + (match[0].length === 0 ? 1 : match[0].length);
                for (const key in match.groups) {
                    if (match.groups[key] !== undefined) {
                        const keys = key.split('_').map((x) => Number.parseInt(x, 10));
                        yield {
                            type: keys[1],
                            index: keys[2],
                            match,
                            nextOffset,
                        };
                        break;
                    }
                }
                regex.lastIndex = nextOffset;
            }
            else {
                break;
            }
        }
    } // }}}
    getCaptureGroupCount(regex) {
        const ast = (0, regexp_1.parse)(regex);
        let count = 0;
        (0, regexp_1.visit)(ast.body, {
            [regexp_1.TokenType.CAPTURE_GROUP]() {
                ++count;
            },
        });
        return count;
    } // }}}
    isSupportedRegex(bypassProtection, ...regexes) {
        if (bypassProtection) {
            return true;
        }
        for (const regex of regexes) {
            if (regex?.test('')) {
                return false;
            }
        }
        return true;
    } // }}}
    listCaptureGroups(regex) {
        const ast = (0, regexp_1.parse)(regex);
        const groups = [];
        (0, regexp_1.visit)(ast.body, {
            [regexp_1.TokenType.CAPTURE_GROUP](token) {
                groups.push(token);
            },
        });
        return groups;
    } // }}}
    pushNewRange(rule, begin, end, foldingRanges, foldLines) {
        foldingRanges.push(new vscode_1.FoldingRange(begin, end, rule.kind));
        if (rule.autoFold) {
            foldLines.push(begin);
        }
    } // }}}
    resolveExplicitRange(document, foldingRanges, name, regexp, stack, endMatches, matchOffset, secondaryLoop, line, offset, foldLines) {
        const text = document.lineAt(line).text;
        for (const { type, index, match, nextOffset } of this.findOfRegexp(regexp, text, offset)) {
            const rule = this.rules[index];
            this.debugChannel?.appendLine(`[${name}] line: ${line + 1}, offset: ${offset}, type: ${Marker[type]}, match: ${match[0]}, regex: ${index}`);
            switch (type) {
                case Marker.BEGIN: {
                    if (stack.length === 0 || stack[0].rule.nested) {
                        if (!rule.nested && (rule.loopRegex ?? rule.endMatcher)) {
                            let loopRegex;
                            if (rule.endMatcher) {
                                let source = rule.loopRegex ? rule.loopRegex.source : '';
                                if (source) {
                                    source += '|';
                                }
                                source += `(?<_${Marker.END}_${index}>${rule.endMatcher(regexp_1.escape, matchOffset, ...match)})`;
                                loopRegex = new RegExp(source, 'g');
                            }
                            else {
                                loopRegex = rule.loopRegex;
                            }
                            const name = rule.name;
                            this.debugChannel?.appendLine(`[${name}] regex: ${loopRegex.toString()}`);
                            const stack = [{ rule, line }];
                            let position = this.resolveExplicitRange(document, foldingRanges, name, loopRegex, stack, {}, 0, true, line, nextOffset, foldLines);
                            while (stack.length > 0 && position.line < document.lineCount) {
                                position = this.resolveExplicitRange(document, foldingRanges, name, loopRegex, stack, {}, 0, true, position.line, position.offset, foldLines);
                            }
                            if (stack.length > 0 && position.line >= document.lineCount) {
                                this.doEOF(document, foldingRanges, stack, foldLines);
                            }
                            return position;
                        }
                        if (rule.endMatcher) {
                            endMatches[rule.index] ||= [];
                            const endMatch = endMatches[rule.index];
                            const end = rule.endMatcher(regexp_1.escape, matchOffset, ...match);
                            let nf = true;
                            let endIndex = endMatch.length + 1;
                            for (const match of endMatch) {
                                if (end === match.regex) {
                                    endIndex = match.index;
                                    nf = false;
                                }
                            }
                            let loopRegex;
                            if (nf) {
                                endMatch.push({
                                    regex: end,
                                    index: endIndex,
                                });
                                loopRegex = new RegExp(`(?<_${Marker.END}_${index}_${endIndex}>${end})|${regexp.source}`, 'g');
                                ++matchOffset;
                            }
                            else {
                                loopRegex = regexp;
                            }
                            const loopStack = [{ rule, line, endIndex }];
                            let position = this.resolveExplicitRange(document, foldingRanges, name, loopRegex, loopStack, endMatches, matchOffset, true, line, nextOffset, foldLines);
                            while (loopStack.length > 0 && position.line < document.lineCount) {
                                position = this.resolveExplicitRange(document, foldingRanges, name, loopRegex, loopStack, endMatches, matchOffset, true, position.line, position.offset, foldLines);
                            }
                            if (nf) {
                                const index = endMatch.findIndex(({ index }) => index === endIndex);
                                endMatch.splice(index, 1);
                            }
                            return position;
                        }
                        if (rule.continuation) {
                            if (!rule.while.test(text)) {
                                return { line: line + 1, offset: 0 };
                            }
                            return this.doWhile(document, foldingRanges, rule, line, true, foldLines);
                        }
                        if (rule.while) {
                            return this.doWhile(document, foldingRanges, rule, line, false, foldLines);
                        }
                        stack.unshift({ rule, line });
                    }
                    break;
                }
                case Marker.MIDDLE: {
                    if (stack.length > 0 && stack[0].rule === rule) {
                        const begin = rule.foldBeforeFirstLine && stack[0].line > 0 && stack[0].line !== line ? stack[0].line - 1 : stack[0].line;
                        const end = line;
                        if (end > begin + 1) {
                            this.pushNewRange(rule, begin, end - 1, foldingRanges, foldLines);
                        }
                        stack[0].line = line;
                    }
                    break;
                }
                case Marker.END: {
                    if (secondaryLoop) {
                        const last = stack.length > 0 && stack.at(-1);
                        if (last && last.rule === rule) {
                            if (last.endIndex && match.groups && !match.groups[`_${Marker.END}_${rule.index}_${last.endIndex}`]) {
                                stack.pop();
                                return { line, offset };
                            }
                            const begin = rule.foldBeforeFirstLine && last.line > 0 && last.line !== line ? last.line - 1 : last.line;
                            const end = rule.consumeEnd() ? line : Math.max(line - 1, begin);
                            while (stack.length > 1) {
                                const begin = stack[0].line;
                                if (end > begin + 1) {
                                    this.pushNewRange(stack[0].rule, begin, end - 1, foldingRanges, foldLines);
                                }
                                stack.shift();
                            }
                            stack.shift();
                            if (rule.foldLastLine()) {
                                if (end > begin) {
                                    this.pushNewRange(rule, begin, end, foldingRanges, foldLines);
                                }
                            }
                            else if (end > begin + 1) {
                                this.pushNewRange(rule, begin, end - 1, foldingRanges, foldLines);
                            }
                            return { line: end, offset: nextOffset };
                        }
                    }
                    if (stack.length > 0 && stack[0].rule === rule) {
                        const begin = rule.foldBeforeFirstLine && stack[0].line > 0 && stack[0].line !== line ? stack[0].line - 1 : stack[0].line;
                        const end = rule.consumeEnd() ? line : Math.max(line - 1, begin);
                        if (rule.foldLastLine(matchOffset, ...match)) {
                            if (end > begin) {
                                this.pushNewRange(rule, begin, end, foldingRanges, foldLines);
                            }
                        }
                        else if (end > begin + 1) {
                            this.pushNewRange(rule, begin, end - 1, foldingRanges, foldLines);
                        }
                        stack.shift();
                    }
                    break;
                }
                case Marker.DOCSTRING: {
                    if (stack.length > 0 && stack[0].rule === rule) {
                        const begin = stack[0].line;
                        const end = line;
                        if (rule.foldLastLine()) {
                            if (end > begin) {
                                this.pushNewRange(rule, begin, end, foldingRanges, foldLines);
                            }
                        }
                        else if (end > begin + 1) {
                            this.pushNewRange(rule, begin, end - 1, foldingRanges, foldLines);
                        }
                        stack.shift();
                    }
                    else if (stack.length === 0 || stack[0].rule.nested) {
                        stack.unshift({ rule, line });
                    }
                    break;
                }
                case Marker.SEPARATOR: {
                    if (stack.length === 0) {
                        if (rule.foldBOF) {
                            if (line > 1) {
                                this.pushNewRange(rule, 0, line - 1, foldingRanges, foldLines);
                            }
                            stack.unshift({ rule, line, separator: true });
                        }
                        else if (!rule.parents || rule.parents.length === 0) {
                            stack.unshift({ rule, line, separator: true });
                        }
                    }
                    else {
                        while (stack.length > 0 && stack[0].rule.parents?.includes(index)) {
                            const begin = stack.shift().line;
                            const end = line;
                            if (end > begin + 1) {
                                this.pushNewRange(rule, begin, end - 1, foldingRanges, foldLines);
                            }
                        }
                        if (stack.length === 0) {
                            if (!rule.parents || rule.parents.length === 0) {
                                stack.unshift({ rule, line, separator: true });
                            }
                        }
                        else if (stack[0].rule === rule) {
                            const begin = stack[0].line;
                            const end = line;
                            if (end > begin + 1) {
                                this.pushNewRange(rule, begin, end - 1, foldingRanges, foldLines);
                            }
                            stack[0].line = line;
                        }
                        else if (stack[0].rule.nested || (secondaryLoop && stack.length === 1)) {
                            if (!rule.parents || rule.parents.length === 0) {
                                stack.unshift({ rule, line, separator: true });
                            }
                            else {
                                const parent = rule.parents.at(-1);
                                if (this.rules[parent].strict) {
                                    if (stack.some(({ rule: { index } }) => parent === index)) {
                                        stack.unshift({ rule, line, separator: true });
                                    }
                                }
                                else if (stack.some(({ rule: { index } }) => rule.parents.includes(index))) {
                                    stack.unshift({ rule, line, separator: true });
                                }
                            }
                        }
                    }
                    break;
                }
                case Marker.WHILE: {
                    return this.doWhile(document, foldingRanges, rule, line, false, foldLines);
                }
            }
        }
        return { line: line + 1, offset: 0 };
    } // }}}
    resolveIndentationRange(document, foldingRanges) {
        const tabSize = vscode_1.window.activeTextEditor ? Number.parseInt(`${vscode_1.window.activeTextEditor.options.tabSize ?? 4}`, 10) : 4;
        this.debugChannel?.appendLine(`[indentation] tabSize: ${tabSize}`);
        const existingRanges = {};
        for (const range of foldingRanges) {
            existingRanges[range.start] = true;
        }
        const previousRegions = [{ indent: -1, begin: document.lineCount, end: document.lineCount }];
        for (let line = document.lineCount - 1; line >= 0; line--) {
            const lineContent = document.lineAt(line).text;
            const indent = computeIndentLevel(lineContent, tabSize);
            this.debugChannel?.appendLine(`[indentation] line: ${line + 1}, indent: ${indent}`);
            let previous = previousRegions.at(-1);
            if (indent === -1) {
                if (this.indentation.offSide) {
                    // for offSide languages, empty lines are associated to the previous block
                    // note: the next block is already written to the results, so this only
                    // impacts the end position of the block before
                    previous.end = line;
                }
                continue; // only whitespace
            }
            if (previous.indent > indent) {
                // discard all regions with larger indent
                do {
                    previousRegions.pop();
                    previous = previousRegions.at(-1);
                } while (previous.indent > indent);
                let fold = true;
                if (this.indentation.filter) {
                    fold = this.indentation.filter.test(lineContent);
                    this.debugChannel?.appendLine(`[indentation] line: ${line + 1}, match(begin): ${fold ? 'yes' : 'no'}`);
                }
                if (fold) {
                    const endLineNumber = previous.end - 1;
                    const block = endLineNumber - line >= 1;
                    if (block && !existingRanges[line]) {
                        foldingRanges.push(new vscode_1.FoldingRange(line, endLineNumber, vscode_1.FoldingRangeKind.Region));
                        if (this.indentation.nestedRegex) {
                            const foldLines = [];
                            const stack = [];
                            const endMatches = {};
                            let position = { line: line + 1, offset: 0 };
                            let targetIndent = -1;
                            while (position.line < endLineNumber) {
                                const lineContent = document.lineAt(position.line).text;
                                const newIndent = computeIndentLevel(lineContent, tabSize);
                                if (newIndent > indent) {
                                    targetIndent = newIndent;
                                    break;
                                }
                                else {
                                    position.line += 1;
                                }
                            }
                            while (position.line < endLineNumber) {
                                const lineContent = document.lineAt(position.line).text;
                                const newIndent = computeIndentLevel(lineContent, tabSize);
                                if (newIndent === targetIndent) {
                                    position = this.resolveExplicitRange(document, foldingRanges, 'indentation', this.indentation.nestedRegex, stack, endMatches, 0, false, position.line, position.offset, foldLines);
                                }
                                else {
                                    position.line += 1;
                                    position.offset = 0;
                                }
                            }
                            while (stack[0]) {
                                if (stack[0].rule.foldEOF) {
                                    const begin = stack[0].line;
                                    if (endLineNumber > begin + 1) {
                                        this.pushNewRange(stack[0].rule, begin, endLineNumber, foldingRanges, foldLines);
                                    }
                                }
                                stack.shift();
                            }
                        }
                    }
                }
                previousRegions.push({ indent, begin: line, end: line });
            }
            else if (previous.indent === indent) {
                previous.end = line;
            }
            else {
                previousRegions.push({ indent, begin: line, end: line });
            }
        }
    } // }}}
}
exports.FoldingProvider = FoldingProvider;


/***/ }),

/***/ 750:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RouteProvider = void 0;
const path_1 = __nccwpck_require__(928);
const minimatch_1 = __nccwpck_require__(772);
const folding_provider_js_1 = __nccwpck_require__(562);
const DIRECTORY = /[/\\]/;
class RouteProvider {
    debugChannel;
    mainProvider;
    routes = [];
    constructor(perFiles, mainProvider, debugChannel, documents, langRules) {
        this.mainProvider = mainProvider;
        this.debugChannel = debugChannel;
        if (!perFiles) {
            return;
        }
        for (const [pattern, rawRules] of Object.entries(perFiles)) {
            if (rawRules) {
                const route = new minimatch_1.Minimatch(`${DIRECTORY.test(pattern) ? '' : '**/'}${pattern}`);
                const rules = this.applyRules(Array.isArray(rawRules) ? rawRules : [rawRules], langRules);
                const provider = new folding_provider_js_1.FoldingProvider(rules, debugChannel, documents);
                this.routes.push({
                    label: pattern,
                    route,
                    provider,
                });
            }
        }
    } // }}}
    provideFoldingRanges(document) {
        this.debugChannel?.show(true);
        for (const { label, route, provider } of this.routes) {
            // eslint-disable-next-line unicorn/prefer-regexp-test
            if (route.match(document.fileName)) {
                this.debugChannel?.appendLine(`[document] fileName: ${(0, path_1.basename)(document.fileName)}, route: ${label}`);
                return provider.provideFoldingRanges(document);
            }
        }
        this.debugChannel?.appendLine(`[document] fileName: ${(0, path_1.basename)(document.fileName)}, route: main`);
        return this.mainProvider.provideFoldingRanges(document);
    } // }}}
    applyRules(rawRules, langRules) {
        const rules = [];
        for (const rule of rawRules) {
            if (rule.include) {
                if (Array.isArray(rule.include)) {
                    for (const lang of rule.include) {
                        rules.push(...langRules[lang]);
                    }
                }
                else {
                    rules.push(...langRules[rule.include]);
                }
            }
            else {
                rules.push(rule);
            }
        }
        return rules;
    } // }}}
}
exports.RouteProvider = RouteProvider;


/***/ }),

/***/ 743:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Disposable = void 0;
const vscode = __importStar(__nccwpck_require__(603));
class Disposable extends vscode.Disposable {
    subscriptions = [];
    constructor() {
        super(() => {
            // do nothing
        });
    }
    dispose() {
        vscode.Disposable.from(...this.subscriptions).dispose();
        this.subscriptions.length = 0;
    }
    push(disposable) {
        this.subscriptions.push(disposable);
    }
}
exports.Disposable = Disposable;


/***/ }),

/***/ 9:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hasValue = hasValue;
function hasValue(object) {
    if (!object) {
        return false;
    }
    for (const key in object) {
        if (Object.hasOwn(object, key)) {
            return true;
        }
    }
    return false;
}


/***/ }),

/***/ 400:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GLOBAL_STORAGE = exports.EXTENSION_ID = exports.EXTENSION_NAME = void 0;
exports.getContext = getContext;
exports.getDebugChannel = getDebugChannel;
exports.setupSettings = setupSettings;
const vscode_1 = __importDefault(__nccwpck_require__(603));
/* eslint-disable import/no-mutable-exports, @typescript-eslint/naming-convention */
exports.EXTENSION_NAME = '';
exports.EXTENSION_ID = '';
exports.GLOBAL_STORAGE = '';
/* eslint-enable */
let $channel = null;
let $context = null;
function getContext() {
    return $context;
}
function getDebugChannel(debug) {
    if (debug) {
        $channel ??= vscode_1.default.window.createOutputChannel(exports.EXTENSION_NAME);
        return $channel;
    }
    return undefined;
} // }}}
async function setupSettings(context) {
    exports.EXTENSION_ID = context.extension.id;
    exports.EXTENSION_NAME = context.extension.packageJSON.displayName;
    exports.GLOBAL_STORAGE = context.globalStorageUri.fsPath;
    $context = context;
}


/***/ }),

/***/ 603:
/***/ ((module) => {

module.exports = eval("require")("vscode");


/***/ }),

/***/ 928:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 330:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"explicit-folding","displayName":"Explicit Folding","description":"Manually controls how and where to fold your code","version":"0.24.2","author":{"name":"Baptiste Augrain","email":"daiyam@zokugun.org"},"publisher":"zokugun","license":"MIT","homepage":"https://github.com/zokugun/vscode-explicit-folding","repository":{"type":"git","url":"https://github.com/zokugun/vscode-explicit-folding.git"},"bugs":{"url":"https://github.com/zokugun/vscode-explicit-folding/issues"},"engines":{"vscode":"^1.23.0"},"main":"./lib/index.js","browser":"./lib/index.js","scripts":{"bundle":"ncc build out/extension --out lib","commit":"cz","compile":"tsc -p src","lint":"xo","package":"rm -f *.vsix && vsce package","prepare":"husky; fixpack || true","release":"release-it","vscode:prepublish":"npm run compile && npm run bundle","watch":"tsc-watch -p src --onSuccess \'npm run bundle\'"},"dependencies":{"@daiyam/regexp":"^0.2.1","@zokugun/vscode.explicit-folding-api":"0.2.1","minimatch":"^5.1.0"},"devDependencies":{"@commitlint/cli":"^19.7.1","@commitlint/config-conventional":"^19.7.1","@types/chai":"^4.2.17","@types/glob":"^7.1.3","@types/klaw-sync":"^6.0.0","@types/mocha":"^8.2.2","@types/node":"^20.14.8","@types/vscode":"^1.23.0","@vercel/ncc":"^0.38.3","chai":"^4.3.4","commitizen":"^4.3.1","fixpack":"^4.0.0","glob":"^7.1.6","husky":"^9.1.7","klaw-sync":"^6.0.0","lint-staged":"^15.4.3","mocha":"^10.1.0","release-it":"^18.1.2","tsc-watch":"^6.3.0","typescript":"^5.7.3","vscode-test":"^1.5.2","xo":"0.60.0","yaml":"^1.10.2"},"activationEvents":["onStartupFinished","onCommand:explicitFolding.nudge"],"capabilities":{"virtualWorkspaces":true,"untrustedWorkspaces":{"supported":true}},"contributes":{"commands":[{"command":"explicitFolding.nudge","title":"Nudge foldings","category":"Explicit Folding"}],"configuration":{"title":"Explicit Folding","properties":{"explicitFolding.additionalSchemes":{"type":"array","default":[],"description":"List of additional schemes on which to the rules. For example: `gitlens`.","scope":"window"},"explicitFolding.autoFold":{"type":"string","default":"none","enum":["1","2","3","4","5","6","7","all","comments","none"],"enumDescriptions":["Folding ranges of level 1 or under","Folding ranges of level 2 or under","Folding ranges of level 3 or under","Folding ranges of level 4 or under","Folding ranges of level 5 or under","Folding ranges of level 6 or under","Folding ranges of level 7 or under","All folding ranges","Comments","No folding ranges"],"scope":"language-overridable"},"explicitFolding.debug":{"type":"boolean","default":false,"description":"Output debug logs.","scope":"language-overridable"},"explicitFolding.delay":{"type":"number","default":1000,"description":"Delay used to defer the registration of the folding providers.","scope":"language-overridable"},"explicitFolding.notification":{"type":"string","default":"minor","enum":["none","major","minor","patch"],"enumDescriptions":["The new version notification won\'t be shown anymore.","The new version notification will be shown only with a new major version","The new version notification will be shown only with a new minor version","The new version notification will always be shown"]},"explicitFolding.perFiles":{"type":"object","description":"Rules to apply to specific files","default":{},"scope":"language-overridable"},"explicitFolding.rules":{"description":"Rules that will determine the folding ranges.","default":[],"scope":"language-overridable"},"explicitFolding.wildcardExclusions":{"type":"array","default":[],"description":"List of languages on which to not apply the wildcard rule (*)."}}}},"extensionKind":["workspace"],"icon":"icon.png","galleryBanner":{"color":"#373b41","theme":"dark"},"categories":["Other"],"keywords":["folding"]}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	if (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = __dirname + "/";
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __nccwpck_require__(390);
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;