import{_ as w,ax as L,ay as j,az as M,aA as Y,l as o,d as H,aB as z,aC as _,ah as q,am as K,ai as O,ag as Q,aD as U,aE as V,aF as W}from"./AugmentMessage-a30kNFnq.js";import{G as k}from"./graph-CI1bWpXD.js";import{l as Z}from"./layout-BfLHOzML.js";import{i as S}from"./_baseUniq-BQilF6Ru.js";import{c as $}from"./clone-KJlz8emn.js";import{m as B}from"./_basePickBy-C2oEnsEv.js";import"./SpinnerAugment-BEPEN2tu.js";import"./CalloutAugment-DzngRWi1.js";import"./TextTooltipAugment-DAVq7Vla.js";import"./BaseButton-DBHsDlhs.js";import"./IconButtonAugment-DT9AU8SC.js";import"./Content-Bm7C6iJ1.js";import"./globals-D0QH3NT1.js";import"./arrow-up-right-from-square-Yo0BPgM2.js";import"./types-DK4HA_lx.js";import"./file-paths-BcSg4gks.js";import"./folder-Cz5snpZv.js";import"./github-kew-evZ8.js";import"./folder-opened-BLAu3pyz.js";import"./types-CGlLNakm.js";import"./file-type-utils-B3gunxPI.js";import"./check-56hMuF8e.js";import"./types-DDm27S8B.js";import"./index-CiMDylqQ.js";import"./utils-Rh_q5w_c.js";import"./ra-diff-ops-model-pDvb0wIq.js";import"./index-DY0Q9XhW.js";import"./CardAugment-RCmwRtRa.js";import"./isObjectLike-C4kUqRHQ.js";import"./TextAreaAugment-C1Wf9cvH.js";import"./diff-utils-CHDUdEQq.js";import"./toggleHighContrast-CwIv4U26.js";import"./preload-helper-Dv6uf1Os.js";import"./index-oyQWDnzB.js";import"./keypress-DD1aQVr0.js";import"./await_block-DO_bDmS_.js";import"./CollapseButtonAugment-CEo2LYfW.js";import"./ButtonAugment-xh-SOBaV.js";import"./MaterialIcon-BGa1zPPN.js";import"./CopyButton-BVbGAvmE.js";import"./magnifying-glass-BmBw0jRN.js";import"./ellipsis-DsAFryUF.js";import"./IconFilePath-BCQiczSW.js";import"./LanguageIcon-CV8JBzL9.js";import"./next-edit-types-904A5ehg.js";import"./Filespan-CId0aUQb.js";import"./lodash-CujEqTm9.js";import"./mcp-logo-C2xFPiFq.js";import"./terminal-CS_V-nAg.js";import"./pen-to-square-DEUxz3in.js";import"./augment-logo-DTgokSKV.js";function X(e){var r={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:ee(e),edges:ne(e)};return S(e.graph())||(r.value=$(e.graph())),r}function ee(e){return B(e.nodes(),function(r){var n=e.node(r),a=e.parent(r),s={v:r};return S(n)||(s.value=n),S(a)||(s.parent=a),s})}function ne(e){return B(e.edges(),function(r){var n=e.edge(r),a={v:r.v,w:r.w};return S(r.name)||(a.name=r.name),S(n)||(a.value=n),a})}var l=new Map,b=new Map,P=new Map,re=w(()=>{b.clear(),P.clear(),l.clear()},"clear"),D=w((e,r)=>{const n=b.get(r)||[];return o.trace("In isDescendant",r," ",e," = ",n.includes(e)),n.includes(e)},"isDescendant"),te=w((e,r)=>{const n=b.get(r)||[];return o.info("Descendants of ",r," is ",n),o.info("Edge is ",e),e.v!==r&&e.w!==r&&(n?n.includes(e.v)||D(e.v,r)||D(e.w,r)||n.includes(e.w):(o.debug("Tilt, ",r,",not in descendants"),!1))},"edgeInCluster"),A=w((e,r,n,a)=>{o.warn("Copying children of ",e,"root",a,"data",r.node(e),a);const s=r.children(e)||[];e!==a&&s.push(e),o.warn("Copying (nodes) clusterId",e,"nodes",s),s.forEach(d=>{if(r.children(d).length>0)A(d,r,n,a);else{const i=r.node(d);o.info("cp ",d," to ",a," with parent ",e),n.setNode(d,i),a!==r.parent(d)&&(o.warn("Setting parent",d,r.parent(d)),n.setParent(d,r.parent(d))),e!==a&&d!==e?(o.debug("Setting parent",d,e),n.setParent(d,e)):(o.info("In copy ",e,"root",a,"data",r.node(e),a),o.debug("Not Setting parent for node=",d,"cluster!==rootId",e!==a,"node!==clusterId",d!==e));const c=r.edges(d);o.debug("Copying Edges",c),c.forEach(p=>{o.info("Edge",p);const E=r.edge(p.v,p.w,p.name);o.info("Edge data",E,a);try{te(p,a)?(o.info("Copying as ",p.v,p.w,E,p.name),n.setEdge(p.v,p.w,E,p.name),o.info("newGraph edges ",n.edges(),n.edge(n.edges()[0]))):o.info("Skipping copy of edge ",p.v,"-->",p.w," rootId: ",a," clusterId:",e)}catch(C){o.error(C)}})}o.debug("Removing node",d),r.removeNode(d)})},"copy"),J=w((e,r)=>{const n=r.children(e);let a=[...n];for(const s of n)P.set(s,e),a=[...a,...J(s,r)];return a},"extractDescendants"),oe=w((e,r,n)=>{const a=e.edges().filter(c=>c.v===r||c.w===r),s=e.edges().filter(c=>c.v===n||c.w===n),d=a.map(c=>({v:c.v===r?n:c.v,w:c.w===r?r:c.w})),i=s.map(c=>({v:c.v,w:c.w}));return d.filter(c=>i.some(p=>c.v===p.v&&c.w===p.w))},"findCommonEdges"),I=w((e,r,n)=>{const a=r.children(e);if(o.trace("Searching children of id ",e,a),a.length<1)return e;let s;for(const d of a){const i=I(d,r,n),c=oe(r,n,i);if(i){if(!(c.length>0))return i;s=i}}return s},"findNonClusterChild"),G=w(e=>l.has(e)&&l.get(e).externalConnections&&l.has(e)?l.get(e).id:e,"getAnchorId"),ie=w((e,r)=>{if(!e||r>10)o.debug("Opting out, no graph ");else{o.debug("Opting in, graph "),e.nodes().forEach(function(n){e.children(n).length>0&&(o.warn("Cluster identified",n," Replacement id in edges: ",I(n,e,n)),b.set(n,J(n,e)),l.set(n,{id:I(n,e,n),clusterData:e.node(n)}))}),e.nodes().forEach(function(n){const a=e.children(n),s=e.edges();a.length>0?(o.debug("Cluster identified",n,b),s.forEach(d=>{D(d.v,n)^D(d.w,n)&&(o.warn("Edge: ",d," leaves cluster ",n),o.warn("Descendants of XXX ",n,": ",b.get(n)),l.get(n).externalConnections=!0)})):o.debug("Not a cluster ",n,b)});for(let n of l.keys()){const a=l.get(n).id,s=e.parent(a);s!==n&&l.has(s)&&!l.get(s).externalConnections&&(l.get(n).id=s)}e.edges().forEach(function(n){const a=e.edge(n);o.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(n)),o.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(e.edge(n)));let s=n.v,d=n.w;if(o.warn("Fix XXX",l,"ids:",n.v,n.w,"Translating: ",l.get(n.v)," --- ",l.get(n.w)),l.get(n.v)||l.get(n.w)){if(o.warn("Fixing and trying - removing XXX",n.v,n.w,n.name),s=G(n.v),d=G(n.w),e.removeEdge(n.v,n.w,n.name),s!==n.v){const i=e.parent(s);l.get(i).externalConnections=!0,a.fromCluster=n.v}if(d!==n.w){const i=e.parent(d);l.get(i).externalConnections=!0,a.toCluster=n.w}o.warn("Fix Replacing with XXX",s,d,n.name),e.setEdge(s,d,a,n.name)}}),o.warn("Adjusted Graph",X(e)),R(e,0),o.trace(l)}},"adjustClustersAndEdges"),R=w((e,r)=>{var s,d;if(o.warn("extractor - ",r,X(e),e.children("D")),r>10)return void o.error("Bailing out");let n=e.nodes(),a=!1;for(const i of n){const c=e.children(i);a=a||c.length>0}if(a){o.debug("Nodes = ",n,r);for(const i of n)if(o.debug("Extracting node",i,l,l.has(i)&&!l.get(i).externalConnections,!e.parent(i),e.node(i),e.children("D")," Depth ",r),l.has(i))if(!l.get(i).externalConnections&&e.children(i)&&e.children(i).length>0){o.warn("Cluster without external connections, without a parent and with children",i,r);let c=e.graph().rankdir==="TB"?"LR":"TB";(d=(s=l.get(i))==null?void 0:s.clusterData)!=null&&d.dir&&(c=l.get(i).clusterData.dir,o.warn("Fixing dir",l.get(i).clusterData.dir,c));const p=new k({multigraph:!0,compound:!0}).setGraph({rankdir:c,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});o.warn("Old graph before copy",X(e)),A(i,e,p,i),e.setNode(i,{clusterNode:!0,id:i,clusterData:l.get(i).clusterData,label:l.get(i).label,graph:p}),o.warn("New graph after copy node: (",i,")",X(p)),o.debug("Old graph after copy",X(e))}else o.warn("Cluster ** ",i," **not meeting the criteria !externalConnections:",!l.get(i).externalConnections," no parent: ",!e.parent(i)," children ",e.children(i)&&e.children(i).length>0,e.children("D"),r),o.debug(l);else o.debug("Not a cluster",i,r);n=e.nodes(),o.warn("New list of nodes",n);for(const i of n){const c=e.node(i);o.warn(" Now next level",i,c),c!=null&&c.clusterNode&&R(c.graph,r+1)}}else o.debug("Done, no node has children",e.nodes())},"extractor"),T=w((e,r)=>{if(r.length===0)return[];let n=Object.assign([],r);return r.forEach(a=>{const s=e.children(a),d=T(e,s);n=[...n,...d]}),n},"sorter"),ae=w(e=>T(e,e.children()),"sortNodesByHierarchy"),F=w(async(e,r,n,a,s,d)=>{o.warn("Graph in recursive render:XAX",X(r),s);const i=r.graph().rankdir;o.trace("Dir in recursive render - dir:",i);const c=e.insert("g").attr("class","root");r.nodes()?o.info("Recursive render XXX",r.nodes()):o.info("No nodes found for",r),r.edges().length>0&&o.info("Recursive edges",r.edge(r.edges()[0]));const p=c.insert("g").attr("class","clusters"),E=c.insert("g").attr("class","edgePaths"),C=c.insert("g").attr("class","edgeLabels"),f=c.insert("g").attr("class","nodes");await Promise.all(r.nodes().map(async function(g){const t=r.node(g);if(s!==void 0){const u=JSON.parse(JSON.stringify(s.clusterData));o.trace(`Setting data for parent cluster XXX
 Node.id = `,g,`
 data=`,u.height,`
Parent cluster`,s.height),r.setNode(s.id,u),r.parent(g)||(o.trace("Setting parent",g,s.id),r.setParent(g,s.id,u))}if(o.info("(Insert) Node XXX"+g+": "+JSON.stringify(r.node(g))),t==null?void 0:t.clusterNode){o.info("Cluster identified XBX",g,t.width,r.node(g));const{ranksep:u,nodesep:m}=r.graph();t.graph.setGraph({...t.graph.graph(),ranksep:u+25,nodesep:m});const N=await F(f,t.graph,n,a,r.node(g),d),x=N.elem;z(t,x),t.diff=N.diff||0,o.info("New compound node after recursive render XAX",g,"width",t.width,"height",t.height),_(x,t)}else r.children(g).length>0?(o.trace("Cluster - the non recursive path XBX",g,t.id,t,t.width,"Graph:",r),o.trace(I(t.id,r)),l.set(t.id,{id:I(t.id,r),node:t})):(o.trace("Node - the non recursive path XAX",g,f,r.node(g),i),await q(f,r.node(g),{config:d,dir:i}))})),await w(async()=>{const g=r.edges().map(async function(t){const u=r.edge(t.v,t.w,t.name);o.info("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(t)),o.info("Edge "+t.v+" -> "+t.w+": ",t," ",JSON.stringify(r.edge(t))),o.info("Fix",l,"ids:",t.v,t.w,"Translating: ",l.get(t.v),l.get(t.w)),await W(C,u)});await Promise.all(g)},"processEdges")(),o.info("Graph before layout:",JSON.stringify(X(r))),o.info("############################################# XXX"),o.info("###                Layout                 ### XXX"),o.info("############################################# XXX"),Z(r),o.info("Graph after layout:",JSON.stringify(X(r)));let y=0,{subGraphTitleTotalMargin:v}=K(d);return await Promise.all(ae(r).map(async function(g){var u;const t=r.node(g);if(o.info("Position XBX => "+g+": ("+t.x,","+t.y,") width: ",t.width," height: ",t.height),t==null?void 0:t.clusterNode)t.y+=v,o.info("A tainted cluster node XBX1",g,t.id,t.width,t.height,t.x,t.y,r.parent(g)),l.get(t.id).node=t,O(t);else if(r.children(g).length>0){o.info("A pure cluster node XBX1",g,t.id,t.x,t.y,t.width,t.height,r.parent(g)),t.height+=v,r.node(t.parentId);const m=(t==null?void 0:t.padding)/2||0,N=((u=t==null?void 0:t.labelBBox)==null?void 0:u.height)||0,x=N-m||0;o.debug("OffsetY",x,"labelHeight",N,"halfPadding",m),await Q(p,t),l.get(t.id).node=t}else{const m=r.node(t.parentId);t.y+=v/2,o.info("A regular node XBX1 - using the padding",t.id,"parent",t.parentId,t.width,t.height,t.x,t.y,"offsetY",t.offsetY,"parent",m,m==null?void 0:m.offsetY,t),O(t)}})),r.edges().forEach(function(g){const t=r.edge(g);o.info("Edge "+g.v+" -> "+g.w+": "+JSON.stringify(t),t),t.points.forEach(x=>x.y+=v/2);const u=r.node(g.v);var m=r.node(g.w);const N=U(E,t,l,n,u,m,a);V(t,N)}),r.nodes().forEach(function(g){const t=r.node(g);o.info(g,t.type,t.diff),t.isGroup&&(y=t.diff)}),o.warn("Returning from recursive render XAX",c,y),{elem:c,diff:y}},"recursiveRender"),on=w(async(e,r)=>{var d,i,c,p,E,C;const n=new k({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:((d=e.config)==null?void 0:d.nodeSpacing)||((c=(i=e.config)==null?void 0:i.flowchart)==null?void 0:c.nodeSpacing)||e.nodeSpacing,ranksep:((p=e.config)==null?void 0:p.rankSpacing)||((C=(E=e.config)==null?void 0:E.flowchart)==null?void 0:C.rankSpacing)||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),a=r.select("g");L(a,e.markers,e.type,e.diagramId),j(),M(),Y(),re(),e.nodes.forEach(f=>{n.setNode(f.id,{...f}),f.parentId&&n.setParent(f.id,f.parentId)}),o.debug("Edges:",e.edges),e.edges.forEach(f=>{if(f.start===f.end){const h=f.start,y=h+"---"+h+"---1",v=h+"---"+h+"---2",g=n.node(h);n.setNode(y,{domId:y,id:y,parentId:g.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),n.setParent(y,g.parentId),n.setNode(v,{domId:v,id:v,parentId:g.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),n.setParent(v,g.parentId);const t=structuredClone(f),u=structuredClone(f),m=structuredClone(f);t.label="",t.arrowTypeEnd="none",t.id=h+"-cyclic-special-1",u.arrowTypeEnd="none",u.id=h+"-cyclic-special-mid",m.label="",g.isGroup&&(t.fromCluster=h,m.toCluster=h),m.id=h+"-cyclic-special-2",n.setEdge(h,y,t,h+"-cyclic-special-0"),n.setEdge(y,v,u,h+"-cyclic-special-1"),n.setEdge(v,h,m,h+"-cyc<lic-special-2")}else n.setEdge(f.start,f.end,{...f},f.id)}),o.warn("Graph at first:",JSON.stringify(X(n))),ie(n),o.warn("Graph after XAX:",JSON.stringify(X(n)));const s=H();await F(a,n,e.type,e.diagramId,void 0,s)},"render");export{on as render};
