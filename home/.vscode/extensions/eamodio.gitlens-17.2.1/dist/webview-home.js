exports.id=928,exports.ids=[928],exports.modules={5101:(e,t,i)=>{i.d(t,{v:()=>SubscriptionManager});let SubscriptionManager=class SubscriptionManager{constructor(e,t){this.source=e,this.subscribe=t}_status="stopped";get status(){return this._status}_subscription;dispose(){this.stop()}start(){(null==this._subscription||"started"!==this._status)&&(this._subscription=this.subscribe(this.source),this._status="started")}pause(){this.stop("paused")}resume(){this.start()}stop(e){this._subscription?.dispose(),this._subscription=void 0,this._status=e??"stopped"}}},8571:(e,t,i)=>{i.d(t,{HomeWebviewProvider:()=>HomeWebviewProvider});var r=i(1398),s=i(9605),o=i(8353),n=i(6378),a=i(6125),h=i(9251),l=i(2863),c=i(9579),p=i(6106),u=i(33),g=i(8679),d=i(1630),m=i(2239),v=i(710),w=i(3715),b=i(3882),f=i(8389),y=i(4291),R=i(9451),C=i(9177),P=i(3262),S=i(6226),_=i(5227),k=i(1137),I=i(7054),B=i(1538),D=i(4422);async function O(e){let t=await e.launchpad.getCategorizedItems();if(null!=t.error)return{error:t.error};let i=B.H.get("launchpad.indicator.groups")??[];return(0,D.a)(t.items,i)}var W=i(9017),T=i(1441),H=i(9235),$=i(7892),L=i(1225),F=i(6866),q=i(8583),E=i(5783),M=i(8492),A=i(5101),x=i(9093),z=i(7938);let U="home",N=new z.Oz(U,"launchpad/summary"),G=new z.Oz(U,"overview/active"),Z=new z.Oz(U,"overview/inactive"),Q=new z.Oz(U,"overviewFilter"),Y=new z.Q2(U,"overview/repository/change"),j=new z.C1(U,"overview/repository/didChange"),V=new z.Q2(U,"previewEnabled/toggle"),J=new z.Q2(U,"section/collapse"),K=new z.Q2(U,"walkthrough/dismiss"),X=new z.Q2(U,"overview/filter/set"),ee=new z.Q2(U,"openInGraph"),et=new z.C1(U,"repositories/didCompleteDiscovering"),ei=new z.C1(U,"previewEnabled/didChange"),er=new z.C1(U,"repository/wip/didChange"),es=new z.C1(U,"repositories/didChange"),eo=new z.C1(U,"walkthroughProgress/didChange"),en=new z.C1(U,"integrations/didChange"),ea=new z.C1(U,"launchpad/didChange"),eh=new z.C1(U,"subscription/didChange"),el=new z.C1(U,"org/settings/didChange"),ec=new z.C1(U,"home/ownerFilter/didChange"),ep=new z.C1(U,"account/didFocus");var eu=Object.defineProperty,eg=Object.getOwnPropertyDescriptor,ed=(e,t,i,r)=>{for(var s,o=r>1?void 0:r?eg(t,i):t,n=e.length-1;n>=0;n--)(s=e[n])&&(o=(r?s(t,i,o):s(o))||o);return r&&o&&eu(t,i,o),o};let em=Object.freeze({dispose:()=>{}}),ev={OneDay:864e5,OneWeek:6048e5,OneMonth:2592e6,OneYear:31536e6};let HomeWebviewProvider=class HomeWebviewProvider{constructor(e,t){this.container=e,this.host=t,this._disposable=r.Disposable.from(this.container.git.onDidChangeRepositories(this.onRepositoriesChanged,this),r.workspace.isTrusted?em:r.workspace.onDidGrantWorkspaceTrust(()=>this.notifyDidChangeRepositories(),this),this.container.subscription.onDidChange(this.onSubscriptionChanged,this),(0,H.wt)(this.onContextChanged,this),this.container.integrations.onDidChange(this.onIntegrationsChanged,this),this.container.walkthrough?.onDidChangeProgress(this.onWalkthroughProgressChanged,this)??em,B.H.onDidChange(this.onDidChangeConfig,this),this.container.launchpad.onDidChange(this.onLaunchpadChanged,this),this.container.ai.onDidChangeModel(this.onAIModelChanged,this))}_disposable;_discovering;_etag;_etagFileSystem;_etagRepository;_etagSubscription;_pendingFocusAccount=!1;dispose(){this._disposable.dispose()}getTelemetryContext(){return{...this.host.getTelemetryContext(),"context.preview":this.getPreviewEnabled()?"v16":void 0}}_overviewBranchFilter={recent:{threshold:"OneWeek"},stale:{threshold:"OneYear",show:!1,limit:9}};onShowing(e,t,...i){this._etag=this.container.git.etag,this.ensureRepoDiscovery();let[r]=i;if(r?.focusAccount===!0){if(!e&&this.host.ready&&this.host.visible)return queueMicrotask(()=>void this.host.notify(ep,void 0)),[!0,void 0];this._pendingFocusAccount=!0}return[!0,void 0]}async ensureRepoDiscovery(){this.container.git.isDiscoveringRepositories&&(this._discovering=this.container.git.isDiscoveringRepositories,this._discovering.finally(()=>this._discovering=void 0),this._etag=await this._discovering,this.notifyDidCompleteDiscoveringRepositories())}onAIModelChanged(e){this.notifyDidChangeIntegrations()}onIntegrationsChanged(e){this.notifyDidChangeIntegrations()}async onChooseRepository(){let e=this.getSelectedRepository(),t=this.container.git.openRepositories.sort((t,i)=>(t===e?1:-1)-(i===e?1:-1)||(t.starred?-1:1)-(i.starred?-1:1)||t.index-i.index),i=await (0,W.oe)(`Switch Repository ${n.EO.Dot} ${e?.name}`,"Choose a repository to switch to",t);if(null!=i&&i!==e)return this.selectRepository(i.path)}onRepositoriesChanged(){null==this._discovering&&this._etag!==this.container.git.etag&&this.notifyDidChangeRepositories()}onWalkthroughProgressChanged(){this.notifyDidChangeProgress()}onDidChangeConfig(e){B.H.changed(e,["home.preview.enabled","ai.enabled"])&&this.notifyDidChangeConfig()}onLaunchpadChanged(){this.notifyDidChangeLaunchpad()}async push(e=!1){let t=this.getSelectedRepository();return t?(0,h.b)({command:"push",state:{repos:[t],flags:e?["--force"]:void 0}}):Promise.resolve()}async publishBranch(e){let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);if(null!=i)return p.VC(t,void 0,(0,w.iw)(i))}async pull(){let e=this.getSelectedRepository();return e?(0,h.b)({command:"pull",state:{repos:[e]}}):Promise.resolve()}registerCommands(){return[(0,T.Lb)(`${this.host.id}.pull`,this.pull,this),(0,T.Lb)(`${this.host.id}.push`,e=>{this.push(e.force)},this),(0,T.Lb)(`${this.host.id}.publishBranch`,this.publishBranch,this),(0,T.Lb)(`${this.host.id}.refresh`,()=>this.host.refresh(!0),this),(0,T.Lb)(`${this.host.id}.disablePreview`,()=>this.onTogglePreviewEnabled(!1),this),(0,T.Lb)(`${this.host.id}.enablePreview`,()=>this.onTogglePreviewEnabled(!0),this),(0,T.Lb)(`${this.host.id}.previewFeedback`,()=>(0,$.CZ)("https://github.com/gitkraken/vscode-gitlens/discussions/3721"),this),(0,T.Lb)(`${this.host.id}.whatsNew`,()=>(0,$.CZ)(n.DS.releaseNotes),this),(0,T.Lb)(`${this.host.id}.help`,()=>(0,$.CZ)(n.DS.helpCenter),this),(0,T.Lb)(`${this.host.id}.issues`,()=>(0,$.CZ)(n.DS.githubIssues),this),(0,T.Lb)(`${this.host.id}.info`,()=>(0,$.CZ)(n.DS.helpCenterHome),this),(0,T.Lb)(`${this.host.id}.discussions`,()=>(0,$.CZ)(n.DS.githubDiscussions),this),(0,T.Lb)(`${this.host.id}.account.resync`,e=>this.container.subscription.validate({force:!0},e),this),(0,T.Lb)("gitlens.home.changeBranchMergeTarget",this.changeBranchMergeTarget,this),(0,T.Lb)("gitlens.home.deleteBranchOrWorktree",this.deleteBranchOrWorktree,this),(0,T.Lb)("gitlens.home.pushBranch",this.pushBranch,this),(0,T.Lb)("gitlens.home.openMergeTargetComparison",this.mergeTargetCompare,this),(0,T.Lb)("gitlens.home.openPullRequestChanges",this.pullRequestChanges,this),(0,T.Lb)("gitlens.home.openPullRequestComparison",this.pullRequestCompare,this),(0,T.Lb)("gitlens.home.openPullRequestOnRemote",this.pullRequestViewOnRemote,this),(0,T.Lb)("gitlens.home.openPullRequestDetails",this.pullRequestDetails,this),(0,T.Lb)("gitlens.home.createPullRequest",this.pullRequestCreate,this),(0,T.Lb)("gitlens.home.openWorktree",this.worktreeOpen,this),(0,T.Lb)("gitlens.home.switchToBranch",this.switchToBranch,this),(0,T.Lb)("gitlens.home.fetch",this.fetch,this),(0,T.Lb)("gitlens.home.openInGraph",this.openInGraph,this),(0,T.Lb)("gitlens.visualizeHistory.repo:home",this.openInTimeline,this),(0,T.Lb)("gitlens.visualizeHistory.branch:home",this.openInTimeline,this),(0,T.Lb)("gitlens.home.createBranch",this.createBranch,this),(0,T.Lb)("gitlens.home.mergeIntoCurrent",this.mergeIntoCurrent,this),(0,T.Lb)("gitlens.home.rebaseCurrentOnto",this.rebaseCurrentOnto,this),(0,T.Lb)("gitlens.home.startWork",this.startWork,this),(0,T.Lb)("gitlens.home.createCloudPatch",this.createCloudPatch,this),(0,T.Lb)("gitlens.home.skipPausedOperation",this.skipPausedOperation,this),(0,T.Lb)("gitlens.home.continuePausedOperation",this.continuePausedOperation,this),(0,T.Lb)("gitlens.home.abortPausedOperation",this.abortPausedOperation,this),(0,T.Lb)("gitlens.home.openRebaseEditor",this.openRebaseEditor,this),(0,T.Lb)("gitlens.home.enableAi",this.enableAi,this),(0,T.Lb)("gitlens.ai.explainWip:home",this.explainWip,this),(0,T.Lb)("gitlens.ai.explainBranch:home",this.explainBranch,this),(0,T.Lb)("gitlens.ai.generateCommits:home",this.generateCommits,this)]}setOverviewFilter(e){this._overviewBranchFilter=e,this.host.notify(ec,{filter:this._overviewBranchFilter})}async onMessageReceived(e){switch(!0){case J.is(e):this.onCollapseSection(e.params);break;case K.is(e):this.dismissWalkthrough();break;case X.is(e):this.setOverviewFilter(e.params);break;case N.is(e):this.host.respond(N,e,await O(this.container));break;case Q.is(e):this.host.respond(Q,e,this._overviewBranchFilter);break;case Y.is(e):if(await this.onChooseRepository()==null)return;this.host.notify(j,void 0);break;case V.is(e):this.onTogglePreviewEnabled();break;case ee.is(e):this.openInGraph(e.params);break;case G.is(e):this.host.respond(G,e,await this.getActiveBranchOverview());break;case Z.is(e):this.host.respond(Z,e,await this.getInactiveBranchOverview())}}includeBootstrap(){return this.getState()}onRefresh(){this.resetBranchOverview(),this.notifyDidChangeRepositories()}onReloaded(){this.onRefresh(),this.notifyDidChangeProgress()}onReady(){!0===this._pendingFocusAccount&&(this._pendingFocusAccount=!1,this.host.notify(ep,void 0))}hasRepositoryChanged(){if(this._repositorySubscription?.source!=null){if(this._repositorySubscription.source.etag!==this._etagRepository||this._repositorySubscription.source.etagFileSystem!==this._etagFileSystem)return!0}else if(this._etag!==this.container.git.etag)return!0;return!1}onVisibilityChanged(e){if(!e)return void this._repositorySubscription?.pause();this._repositorySubscription?.resume(),null==this._discovering&&(this.container.subscription.etag!==this._etagSubscription||this.hasRepositoryChanged())&&this.notifyDidChangeRepositories(!0)}openInGraph(e){let t=null!=e?this._repositoryBranches.get(e.repoPath):void 0;if(null==t)return void(0,T.RS)("gitlens.showGraph",this.getSelectedRepository());if("branch"===e.type){let i=t.branches.find(t=>t.id===e.branchId);if(null!=i)return void(0,T.RS)("gitlens.showInCommitGraph",{ref:(0,w.iw)(i)})}(0,T.RS)("gitlens.showGraph",t.repo)}openInTimeline(e){let t=null==e?this.getSelectedRepository():this.container.git.getRepository(e.repoPath);if(null!=t){if(e?.type==="repo")return void(0,T.RS)("gitlens.visualizeHistory",{type:"repo",uri:t.uri});if(e?.type==="branch"){let i=this._repositoryBranches.get(t.path),r=i?.branches.find(t=>t.id===e.branchId);null!=r&&(0,T.RS)("gitlens.visualizeHistory",{type:"repo",uri:t.uri,head:(0,w.iw)(r)})}}}createBranch(){this.container.telemetry.sendEvent("home/createBranch"),(0,T.RS)("gitlens.gitCommands",{command:"branch",state:{subcommand:"create",repo:this.getSelectedRepository(),suggestNameOnly:!0,suggestRepoOnly:!0,confirmOptions:["--switch","--worktree"]}})}changeBranchMergeTarget(e){this.container.telemetry.sendEvent("home/changeBranchMergeTarget"),(0,T.RS)("gitlens.changeBranchMergeTarget",{command:"changeBranchMergeTarget",state:{repo:e.repoPath,branch:e.branchName,mergeBranch:e.mergeTargetName}})}async mergeIntoCurrent(e){let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);null!=i&&p.h1(t,(0,w.iw)(i))}async rebaseCurrentOnto(e){let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);null!=i&&p.RU(t,(0,w.iw)(i))}async explainBranch(e){let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);null!=t&&(0,T.RS)("gitlens.ai.explainBranch",{repoPath:t.path,ref:i?.ref,source:{source:"home",type:"branch"}})}async explainWip(e){let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);if(null==t)return;let r=await i?.getWorktree();(0,T.RS)("gitlens.ai.explainWip",{repoPath:t.path,worktreePath:r?.path,source:{source:"home",type:"wip"}})}async generateCommits(e){let{repo:t}=await this.getRepoInfoFromRef(e);null!=t&&(0,T.RS)("gitlens.ai.generateCommits",{repoPath:t.path,source:{source:"home"}})}enableAi(){this.container.telemetry.sendEvent("home/enableAi"),B.H.updateEffective("ai.enabled",!0)}startWork(){this.container.telemetry.sendEvent("home/startWork"),(0,T.RS)("gitlens.startWork",{command:"startWork",source:"home"})}async abortPausedOperation(e){await (0,c._e)(this.container.git.getRepositoryService(e.repoPath))}async continuePausedOperation(e){"revert"!==e.type&&await (0,c.Ts)(this.container.git.getRepositoryService(e.repoPath))}async skipPausedOperation(e){await (0,c.RG)(this.container.git.getRepositoryService(e.repoPath))}async openRebaseEditor(e){if("rebase"!==e.type)return;let t=await this.container.git.getRepositoryService(e.repoPath).config.getGitDir?.();if(null==t)return;let i=r.Uri.joinPath(t.uri,"rebase-merge","git-rebase-todo");(0,T.S4)("vscode.openWith",i,"gitlens.rebase",{preview:!1})}async createCloudPatch(e){let{repo:t}=await this.getRepoInfoFromRef(e);if(null==t)return;let i=await t.git.status.getStatus();if(null==i)return void r.window.showErrorMessage("Unable to create cloud patch");let s=[];for(let e of i.files){let t={repoPath:e.repoPath,path:e.path,status:e.status,originalPath:e.originalPath,staged:e.staged};s.push(t),e.staged&&e.wip&&s.push({...t,staged:!1})}let o={type:"wip",repository:{name:t.name,path:t.path,uri:t.uri.toString()},files:s,revision:{to:d.SU,from:"HEAD"}};(0,S.X)({mode:"create",create:{changes:[o]}})}onTogglePreviewEnabled(e){void 0===e&&(e=!this.getPreviewEnabled()),this.getPreviewCollapsed()||this.onCollapseSection({section:"newHomePreview",collapsed:!0}),this.container.telemetry.sendEvent("home/preview/toggled",{enabled:e,version:"v16"}),B.H.updateEffective("home.preview.enabled",e)}onCollapseSection(e){let t=this.container.storage.get("home:sections:collapsed");if(null==t){!0===e.collapsed&&this.container.storage.store("home:sections:collapsed",[e.section]).catch();return}let i=t.indexOf(e.section);if(!0===e.collapsed){-1===i&&this.container.storage.store("home:sections:collapsed",[...t,e.section]).catch();return}-1!==i&&(t.splice(i,1),this.container.storage.store("home:sections:collapsed",t).catch())}dismissWalkthrough(){this.container.storage.get("home:walkthrough:dismissed")||(this.container.storage.store("home:walkthrough:dismissed",!0).catch(),this.container.usage.track("home:walkthrough:dismissed").catch())}getWalkthroughDismissed(){return null==this.container.walkthrough||(this.container.storage.get("home:walkthrough:dismissed")??!1)}getPreviewCollapsed(){return this.container.storage.get("home:sections:collapsed")?.includes("newHomePreview")??!1}getAiEnabled(){return B.H.get("ai.enabled")}getAmaBannerCollapsed(){return Date.now()>=new Date("2025-02-13T13:00:00-05:00").getTime()||(this.container.storage.get("home:sections:collapsed")?.includes("feb2025AmaBanner")??!1)}getIntegrationBannerCollapsed(){return this.container.storage.get("home:sections:collapsed")?.includes("integrationBanner")??!1}getOrgSettings(){return{drafts:(0,H.SD)("gitlens:gk:organization:drafts:enabled",!1),ai:(0,H.SD)("gitlens:gk:organization:ai:enabled",!0)}}onContextChanged(e){["gitlens:gk:organization:ai:enabled","gitlens:gk:organization:drafts:enabled"].includes(e)&&this.notifyDidChangeOrgSettings()}async onSubscriptionChanged(e){e.etag!==this._etagSubscription&&(await this.notifyDidChangeSubscription(e.current),(0,_.aE)(e.current.state)!==(0,_.aE)(e.previous.state)&&this.onOverviewRepoChanged())}async getState(e){let[t,i,r]=await Promise.allSettled([this.getSubscriptionState(e),this.getIntegrationStates(!0),this.container.ai.getModel({silent:!0},{source:"home"})]);if("rejected"===t.status)throw t.reason;let s=(0,M.Ro)(i)??[],o=s.some(e=>e.connected),n={model:(0,M.Ro)(r)};return{...this.host.baseWebviewState,discovering:null!=this._discovering,repositories:this.getRepositoriesState(),webroot:this.host.getWebRoot(),subscription:t.value.subscription,avatar:t.value.avatar,organizationsCount:t.value.organizationsCount,orgSettings:this.getOrgSettings(),aiEnabled:this.getAiEnabled(),previewCollapsed:this.getPreviewCollapsed(),integrationBannerCollapsed:this.getIntegrationBannerCollapsed(),integrations:s,ai:n,hasAnyIntegrationConnected:o,walkthroughSupported:null!=this.container.walkthrough,walkthroughProgress:this.getWalkthroughDismissed()||null==this.container.walkthrough?void 0:{allCount:this.container.walkthrough.walkthroughSize,doneCount:this.container.walkthrough.doneCount,progress:this.container.walkthrough.progress},previewEnabled:this.getPreviewEnabled(),newInstall:(0,H.SD)("gitlens:install:new",!1),amaBannerCollapsed:this.getAmaBannerCollapsed()}}getPreviewEnabled(){return B.H.get("home.preview.enabled")}getRepositoriesState(){return{count:this.container.git.repositoryCount,openCount:this.container.git.openRepositoryCount,hasUnsafe:this.container.git.hasUnsafeRepositories(),trusted:r.workspace.isTrusted}}async getActiveBranchOverview(){null!=this._discovering&&await this._discovering;let e=this.getSelectedRepository();if(null==e)return;let t="repo"===this._invalidateOverview,i="wip"===this._invalidateOverview,[r,s,o]=await Promise.allSettled([this.getBranchesData(e,t),this.isSubscriptionPro(),this.formatRepository(e)]),{branches:n,worktreesByBranch:a}=(0,M.Ro)(r),h=n.find(e=>"active"===this.getBranchOverviewType(e,a)),l=(0,M.Ro)(s),[c]=ew(this.container,[h],a,l,{isActive:!0,forceStatus:!!t||!!i||void 0});return i&&(this._invalidateOverview=void 0),this._etagFileSystem=e.etagFileSystem,{repository:(0,M.Ro)(o),active:c}}async getInactiveBranchOverview(){let e;null!=this._discovering&&await this._discovering;let t=this.getSelectedRepository();if(null==t)return;let i="repo"===this._invalidateOverview,[r,s,o]=await Promise.allSettled([this.getBranchesData(t,i),this.isSubscriptionPro(),this.formatRepository(t)]),{branches:n,worktreesByBranch:a}=(0,M.Ro)(r),h=n.filter(e=>"recent"===this.getBranchOverviewType(e,a)),l=(0,M.Ro)(s);if(this._overviewBranchFilter.stale.show)for(let t of((0,f.Xn)(n,{missingUpstream:!0,orderBy:"date:asc"}),n)){if(null!=e&&e.length>this._overviewBranchFilter.stale.limit)break;h.some(e=>e.id===t.id)||"stale"===this.getBranchOverviewType(t,a)&&(e??=[]).push(t)}let c=ew(this.container,h,a,l),p=null==e?void 0:ew(this.container,e,a,l);return i||(this._invalidateOverview=void 0),{repository:(0,M.Ro)(o),recent:c,stale:p}}async formatRepository(e){let t=await e.git.remotes.getBestRemotesWithProviders(),i=t.find(e=>e.supportsIntegration())??t[0];return(0,b.GS)(e,i)}_repositorySubscription;selectRepository(e){let t;return null!=e?t=this.container.git.getRepository(e):null==(t=this.container.git.highlander)&&(t=this.container.git.getBestRepositoryOrFirst()),this._repositorySubscription?.dispose(),this._repositorySubscription=void 0,null!=t&&(this._repositorySubscription=new A.v(t,e=>this.subscribeToRepository(e)),this.host.visible&&this._repositorySubscription.start()),t}resetBranchOverview(){if(this._repositoryBranches.clear(),!this.host.visible)return void this._repositorySubscription?.pause();this._repositorySubscription?.resume()}subscribeToRepository(e){return r.Disposable.from(e.watchFileSystem(1e3),e.onDidChangeFileSystem(t=>this.onOverviewWipChanged(t,e)),e.onDidChange(t=>{t.changed(g.Z_.Config,g.Z_.Head,g.Z_.Heads,g.Z_.Remotes,g.Z_.PausedOperationStatus,g.Z_.Unknown,g.Ti.Any)&&this.onOverviewRepoChanged(e)}))}onOverviewWipChanged(e,t){e.repository.id===t.id&&this._etagFileSystem!==t.etagFileSystem&&("repo"!==this._invalidateOverview&&(this._invalidateOverview="wip"),this.host.visible&&this.host.notify(er,void 0))}onOverviewRepoChanged(e){if(null!=e){if(this._etagRepository===e.etag)return}else if(this._etag===this.container.git.etag)return;this._invalidateOverview="repo",this.host.visible&&this.notifyDidChangeRepositories()}getSelectedRepository(){return null==this._repositorySubscription&&this.selectRepository(),this._repositorySubscription?.source}_invalidateOverview;_repositoryBranches=new Map;async getBranchesData(e,t=!1){if(t||!this._repositoryBranches.has(e.path)||e.etag!==this._etagRepository){let t=await e.git.worktrees?.getWorktrees()??[],i=(0,y.PU)(t,{includeDefault:!0}),[r]=await Promise.allSettled([e.git.branches.getBranches({filter:e=>!e.remote,sort:{current:!0,openedWorktreesByBranch:(0,y.vJ)(i)}})]),s=(0,M.Ro)(r)?.values??[];this._etagRepository=e.etag,this._repositoryBranches.set(e.path,{repo:e,branches:s,worktreesByBranch:i})}return this._repositoryBranches.get(e.path)}_integrationStates;_defaultSupportedCloudIntegrations;async getIntegrationStates(e=!1){if(e||null==this._integrationStates){let e=(0,E.x1)(await this.container.integrations.getConfigured(),e=>{if(!(0,a.LT)(e.integrationId))return;let t=a.U4.find(t=>t.id===e.integrationId);return{id:e.integrationId,name:k.Mt[e.integrationId].name,icon:`gl-provider-${k.Mt[e.integrationId].iconKey}`,connected:!0,supports:t?.supports!=null?t.supports:"git"===k.Mt[e.integrationId].type?["prs","issues"]:"issues"===k.Mt[e.integrationId].type?["issues"]:[],requiresPro:t?.requiresPro??!1}}),t=await Promise.allSettled(e),i=[...(0,E.x1)(t,e=>(0,M.Ro)(e))];this._defaultSupportedCloudIntegrations??=a.U4.map(e=>({...e,connected:!1})),this._defaultSupportedCloudIntegrations.forEach(e=>{let t=i.find(t=>t.id===e.id);null==t?i.push(e):t.icon!==e.icon&&(t.icon=e.icon)}),i.sort((e,t)=>a.rK.indexOf(e.id)-a.rK.indexOf(t.id)),this._integrationStates=i}return this._integrationStates}_subscription;async getSubscription(e){return null!=e?this._subscription=e:null!=this._subscription?e=this._subscription:this._subscription=e=await this.container.subscription.getSubscription(!0),this._subscription}async isSubscriptionPro(){let e=await this.getSubscription();return null!=e&&(0,_.aE)(e.state)}async getSubscriptionState(e){let t;return e=await this.getSubscription(e),this._etagSubscription=this.container.subscription.etag,t=e.account?.email?(0,o.ML)(e.account.email,34).toString():`${this.host.getWebRoot()??""}/media/gitlens-logo.webp`,{subscription:e,avatar:t,organizationsCount:null!=e?(await this.container.organizations.getOrganizations()??[]).length:0}}notifyDidCompleteDiscoveringRepositories(){this.host.notify(et,{discovering:null!=this._discovering,repositories:this.getRepositoriesState()})}notifyDidChangeRepositoriesCore(){this.host.notify(es,this.getRepositoriesState())}_notifyDidChangeRepositoriesDebounced=void 0;notifyDidChangeRepositories(e=!1){if(null==this._discovering){if(e)return void this.notifyDidChangeRepositoriesCore();null==this._notifyDidChangeRepositoriesDebounced&&(this._notifyDidChangeRepositoriesDebounced=(0,q.s)(this.notifyDidChangeRepositoriesCore.bind(this),500)),this._notifyDidChangeRepositoriesDebounced()}}notifyDidChangeProgress(){null!=this.container.walkthrough&&this.host.notify(eo,{allCount:this.container.walkthrough.walkthroughSize,doneCount:this.container.walkthrough.doneCount,progress:this.container.walkthrough.progress})}notifyDidChangeConfig(){this.host.notify(ei,{previewEnabled:this.getPreviewEnabled(),previewCollapsed:this.getPreviewCollapsed(),aiEnabled:this.getAiEnabled()})}notifyDidChangeLaunchpad(){this.host.notify(ea,void 0)}async notifyDidChangeIntegrations(){let[e,t]=await Promise.allSettled([this.getIntegrationStates(!0),this.container.ai.getModel({silent:!0},{source:"home"})]),i=(0,M.Ro)(e)??[],r=i.some(e=>e.connected),s={model:(0,M.Ro)(t)};r&&this.onCollapseSection({section:"integrationBanner",collapsed:!0}),this.host.notify(en,{hasAnyIntegrationConnected:r,integrations:i,ai:s})}async notifyDidChangeSubscription(e){let t=await this.getSubscriptionState(e);this.host.notify(eh,{subscription:t.subscription,avatar:t.avatar,organizationsCount:t.organizationsCount})}notifyDidChangeOrgSettings(){this.host.notify(el,{orgSettings:this.getOrgSettings()})}async deleteBranchOrWorktree(e,t){let{repo:i,branch:s}=await this.getRepoInfoFromRef(e);if(null==s)return;let o=!1===s.worktree?void 0:s.worktree??await s.getWorktree();if(s.current&&null!=t&&(!o||o.isDefault)){let i=(0,R.km)(t.branchName),o=await r.window.showWarningMessage(`Before deleting the current branch '${s.name}', you will be switched to '${i}'.`,{modal:!0},{title:"Continue"});if(null==o||"Continue"!==o.title)return;await this.container.git.getRepositoryService(e.repoPath).checkout(i),(0,h.b)({command:"branch",state:{subcommand:"delete",repo:e.repoPath,references:s}})}else if(null!=i&&null!=o&&!o.isDefault){let e=await i.getCommonRepository(),t=await i.git.worktrees?.getWorktree(e=>e.isDefault);if(null==t||null==e)return;let o=await r.window.showWarningMessage(`Before deleting the worktree for '${s.name}', you will be switched to the default worktree.`,{modal:!0},{title:"Continue"});if(null==o||"Continue"!==o.title)return;let n=B.H.get("deepLinks.schemeOverride"),a="string"==typeof n?n:r.env.uriScheme,l={url:`${a}://${this.container.context.extension.id}/link/${x.vk.Repository}/-/${x.vk.Branch}/${encodeURIComponent(s.name)}?path=${encodeURIComponent(e.path)}&action=delete-branch`,repoPath:e.path,useProgress:!1,state:x.rq.GoToTarget};(0,h.b)({command:"worktree",state:{subcommand:"open",repo:t.repoPath,worktree:t,onWorkspaceChanging:async e=>{await this.container.storage.storeSecret("deepLinks:pending",JSON.stringify(l)),setTimeout(()=>{(0,T.S4)("workbench.action.closeWindow")},2e3)},worktreeDefaultOpen:"current"}})}}pushBranch(e){this.container.git.getRepositoryService(e.repoPath).push({reference:{name:e.branchName,ref:e.branchId,refType:"branch",remote:!1,repoPath:e.repoPath,upstream:e.branchUpstreamName?{name:e.branchUpstreamName,missing:!1}:void 0}})}mergeTargetCompare(e){return this.container.views.searchAndCompare.compare(e.repoPath,e.branchName,e.mergeTargetName)}async pullRequestCompare(e){let t=await this.getPullRequestFromRef(e);if(t?.refs?.base==null||null==t.refs.head)return void r.window.showErrorMessage("Unable to find pull request to compare");let i=(0,C.tI)(e.repoPath,t.refs);return this.container.views.searchAndCompare.compare(i.repoPath,i.head,i.base)}async pullRequestChanges(e){let t=await this.getPullRequestFromRef(e);if(t?.refs?.base==null||null==t.refs.head)return void r.window.showErrorMessage("Unable to find pull request to open changes");let i=(0,C.tI)(e.repoPath,t.refs);return(0,l.$5)(this.container,{repoPath:i.repoPath,lhs:i.base.ref,rhs:i.head.ref},{title:`Changes in Pull Request #${t.id}`})}async pullRequestViewOnRemote(e,t){let i=await this.getPullRequestFromRef(e);if(null==i)return void r.window.showErrorMessage("Unable to find pull request to open on remote");(0,T.RS)("gitlens.openPullRequestOnRemote",{pr:{url:i.url},clipboard:t})}async pullRequestDetails(e){let t=await this.getPullRequestFromRef(e);if(null==t)return void r.window.showErrorMessage("Unable to find pull request to open details");this.container.views.pullRequest.showPullRequest(t,e.repoPath)}async pullRequestCreate({ref:e,describeWithAI:t,source:i}){let{branch:r}=await this.getRepoInfoFromRef(e);if(null==r)return;let o=await r.getRemote(),n=t?this.container.actionRunners.get("createPullRequest")?.find(e=>e.type===s.do.BuiltIn)?.id:void 0;(0,T.ph)("createPullRequest",{repoPath:e.repoPath,remote:null!=o?{name:o.name,provider:null!=o.provider?{id:o.provider.id,name:o.provider.name,domain:o.provider.domain}:void 0,url:o.url}:void 0,branch:{name:r.name,upstream:r.upstream?.name,isRemote:r.remote},describeWithAI:t,source:i},n)}async worktreeOpen(e){let{location:t,...i}=e,{branch:r}=await this.getRepoInfoFromRef(i),s=await r?.getWorktree();null!=s&&(0,L.OH)(s.uri,t?{location:t}:void 0)}async switchToBranch(e){let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);null!=i&&p.S_(t,(0,w.iw)(i))}async fetch(e){if(null==e){let e=this.getSelectedRepository();p.hd(e);return}let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);null!=i&&p.hd(t,(0,w.iw)(i))}getBranchOverviewType(e,t){if(e.current||t.get(e.id)?.opened)return"active";let i=e.date?.getTime();if(null!=i){let e=Date.now();if(i>e-ev[this._overviewBranchFilter.recent.threshold])return"recent";if(i<e-ev[this._overviewBranchFilter.stale.threshold])return"stale"}if(e.upstream?.missing)return"stale"}async getPullRequestFromRef(e){let{branch:t}=await this.getRepoInfoFromRef(e);return t?.getAssociatedPullRequest()}async getRepoInfoFromRef(e){let t=this.container.git.getRepository(e.repoPath);if(null==t)return{repo:void 0,branch:void 0};let i=await t.git.branches.getBranch(e.branchName);return{repo:t,branch:i}}};function ew(e,t,i,r,s){let o,n;if(0===t.length)return[];let a=s?.isActive??!1,h=s?.forceStatus?{force:!0}:void 0,l=new Map,c=new Map,p=new Map,g=new Map,d=new Map,v=new Map,b=new Map,f=[];for(let s of t){s.upstream?.missing===!1&&l.set(s.id,s.getRemote());let t=i.get(s.id),u=s.date?.getTime();!0===r&&(c.set(s.id,eC(e,s,o)),p.set(s.id,s.getEnrichedAutolinks()),g.set(s.id,(0,m.GI)(e,s).then(e=>e.value)),v.set(s.id,e.git.getRepositoryService(s.repoPath).branches.getBranchContributionsOverview(s.ref)),s.current&&b.set(s.id,ey(e,s))),null!=t?d.set(s.id,t.getStatus(h)):!0===a&&(void 0===n&&(n=e.git.getRepositoryService(s.repoPath).status.getStatus()),d.set(s.id,n)),f.push({reference:(0,w.iw)(s),repoPath:s.repoPath,id:s.id,name:s.name,opened:a,timestamp:u,status:s.status,upstream:s.upstream,worktree:t?{name:t.name,uri:t.uri.toString(),isDefault:t.isDefault}:void 0})}return f.length>0&&function(e,t,i,r,s,o,n,a,h,l){for(let c of t){c.remote=r.get(c.id)?.then(async e=>{if(null!=e)return{name:e.name,provider:e.provider?{name:e.provider.name,icon:"remote"===e.provider.icon?"cloud":e.provider.icon,url:await e.provider.url({type:u.J.Repo}),supportedFeatures:e.provider.supportedFeatures}:void 0}}),c.pr=s.get(c.id);let t=o.get(c.id);c.autolinks=t?.then(e=>eb(e));let p=n.get(c.id);c.issues=p?.then(e=>e?.map(e=>({id:e.id,title:e.title,state:e.state,url:e.url}))??[]),c.wip=eP(e,c,a.get(c.id),i);let g=h.get(c.id);c.contributors=ef(e,g),c.mergeTarget=l.get(c.id)}}(e,f,a,l,c,p,g,d,v,b),f}async function eb(e){return null==e?[]:(await Promise.allSettled((0,E.x1)([...e.values()],async e=>{let t=e?.[0];if(null==t)return;let i=await t;if(null!=i)return{id:i.id,title:i.title,url:i.url,state:i.state}}))).map(e=>"fulfilled"===e.status?e.value:void 0).filter(e=>null!=e)}async function ef(e,t){if(null==t)return[];let i=await t;return i?.contributors==null?[]:(await Promise.allSettled(i.contributors.map(async e=>({name:e.name??"",email:e.email??"",current:e.current,timestamp:e.latestCommitDate?.getTime(),count:e.contributionCount,stats:e.stats,avatarUrl:(await e.getAvatarUri())?.toString()})))).map(e=>"fulfilled"===e.status?e.value:void 0).filter(e=>null!=e)}async function ey(e,t){let i,r=await (0,v.Y7)(e,t,{associatedPullRequest:t.getAssociatedPullRequest()});!r.mergeTargetBranch.paused&&r.mergeTargetBranch.value&&(i=r.mergeTargetBranch.value);let s=i??r.baseBranch??r.defaultBranch;if(null==s)return;let o=e.git.getRepositoryService(t.repoPath),n=await o.branches.getBranch(s);if(null==n)return;let[a,h,l]=await Promise.allSettled([o.commits.getLeftRightCommitCount((0,P.Xn)(n.name,t.ref,"..."),{excludeMerges:!0}),o.branches.getPotentialMergeOrRebaseConflict?.(t.name,n.name),o.branches.getBranchMergedStatus?.(t,n)]),c=(0,M.Ro)(a),p=null!=c?{ahead:c.right,behind:c.left}:void 0,u=(0,M.Ro)(l);return{repoPath:t.repoPath,id:n.id,name:n.name,status:p,mergedStatus:u,potentialConflicts:(0,M.Ro)(h),targetBranch:n.name,baseBranch:r.baseBranch,defaultBranch:r.defaultBranch}}async function eR(e,t,i){i??=e.launchpad.getCategorizedItems();let r=await i;if(null!=r.error)return;let s=r.items.find(e=>e.url===t.url);if(null==s){if(null!=(r=await e.launchpad.getCategorizedItems({search:[t]})).error)return;s=r.items.find(e=>e.url===t.url)}if(null!=s)return{uuid:s.uuid,category:s.actionableCategory,groups:(0,I._v)(s),suggestedActions:s.suggestedActions,failingCI:s.failingCI,hasConflicts:s.hasConflicts,review:{decision:s.reviewDecision,reviews:s.reviews??[],counts:{approval:s.approvalReviewCount,changeRequest:s.changeRequestReviewCount,comment:s.commentReviewCount,codeSuggest:s.codeSuggestionsCount}},author:s.author,createdDate:s.createdDate,viewer:{...s.viewer,enrichedItems:void 0}}}async function eC(e,t,i){let r=await t.getAssociatedPullRequest({avatarSize:64});if(null!=r)return{id:r.id,url:r.url,state:r.state,title:r.title,draft:r.isDraft,launchpad:eR(e,r,i)}}async function eP(e,t,i,r){if(null==i)return;let[s,o]=await Promise.allSettled([i,r?e.git.getRepositoryService(t.repoPath).status.getPausedOperationStatus?.():void 0]),n=(0,M.Ro)(s),a=(0,M.Ro)(o);return{workingTreeState:n?.getDiffStatus(),hasConflicts:n?.hasConflicts,conflictsCount:n?.conflicts.length,pausedOpStatus:a}}ed([(0,F.Rm)({args:{0:e=>`${e?.type}, repoPath=${e?.repoPath}, branchId=${e?.branchId}`}})],HomeWebviewProvider.prototype,"openInGraph",1),ed([(0,F.Rm)({args:{0:e=>`${e?.type}, repoPath=${e?.repoPath}, branchId=${e?.branchId}`}})],HomeWebviewProvider.prototype,"openInTimeline",1),ed([(0,F.Rm)()],HomeWebviewProvider.prototype,"createBranch",1),ed([(0,F.Rm)()],HomeWebviewProvider.prototype,"changeBranchMergeTarget",1),ed([(0,F.Rm)({args:{0:e=>e.branchId}})],HomeWebviewProvider.prototype,"mergeIntoCurrent",1),ed([(0,F.Rm)({args:{0:e=>e.branchId}})],HomeWebviewProvider.prototype,"rebaseCurrentOnto",1),ed([(0,F.Rm)({args:{0:e=>e.branchId}})],HomeWebviewProvider.prototype,"explainBranch",1),ed([(0,F.Rm)({args:{0:e=>e.branchId}})],HomeWebviewProvider.prototype,"explainWip",1),ed([(0,F.Rm)({args:{0:e=>e.branchId}})],HomeWebviewProvider.prototype,"generateCommits",1),ed([(0,F.Rm)()],HomeWebviewProvider.prototype,"enableAi",1),ed([(0,F.Rm)()],HomeWebviewProvider.prototype,"startWork",1),ed([(0,F.Rm)({args:{0:e=>e.type}})],HomeWebviewProvider.prototype,"abortPausedOperation",1),ed([(0,F.Rm)({args:{0:e=>e.type}})],HomeWebviewProvider.prototype,"continuePausedOperation",1),ed([(0,F.Rm)({args:{0:e=>e.type}})],HomeWebviewProvider.prototype,"skipPausedOperation",1),ed([(0,F.Rm)({args:{0:e=>e.type}})],HomeWebviewProvider.prototype,"openRebaseEditor",1),ed([(0,F.Rm)({args:{0:e=>e.branchId}})],HomeWebviewProvider.prototype,"createCloudPatch",1),ed([(0,F.Rm)()],HomeWebviewProvider.prototype,"dismissWalkthrough",1),ed([(0,F.Yz)({args:!1})],HomeWebviewProvider.prototype,"onSubscriptionChanged",1),ed([(0,F.Yz)({args:{0:!1}})],HomeWebviewProvider.prototype,"onOverviewWipChanged",1),ed([(0,F.Yz)()],HomeWebviewProvider.prototype,"onOverviewRepoChanged",1),ed([(0,F.Rm)({args:{0:e=>`${e.branchId}, upstream: ${e.branchUpstreamName}`,1:e=>e?.branchId}})],HomeWebviewProvider.prototype,"deleteBranchOrWorktree",1),ed([(0,F.Rm)({args:{0:e=>`${e.branchId}, upstream: ${e.branchUpstreamName}`}})],HomeWebviewProvider.prototype,"pushBranch",1),ed([(0,F.Rm)({args:{0:e=>`${e.branchId}, upstream: ${e.branchUpstreamName}, mergeTargetId: ${e.mergeTargetId}`}})],HomeWebviewProvider.prototype,"mergeTargetCompare",1),ed([(0,F.Rm)({args:{0:e=>`${e.branchId}, upstream: ${e.branchUpstreamName}`}})],HomeWebviewProvider.prototype,"pullRequestCompare",1),ed([(0,F.Rm)({args:{0:e=>`${e.branchId}, upstream: ${e.branchUpstreamName}`}})],HomeWebviewProvider.prototype,"pullRequestChanges",1),ed([(0,F.Rm)({args:{0:e=>`${e.branchId}, upstream: ${e.branchUpstreamName}`}})],HomeWebviewProvider.prototype,"pullRequestViewOnRemote",1),ed([(0,F.Rm)({args:{0:e=>`${e.branchId}, upstream: ${e.branchUpstreamName}`}})],HomeWebviewProvider.prototype,"pullRequestDetails",1),ed([(0,F.Rm)({args:{0:e=>`${e.ref.branchId}, upstream: ${e.ref.branchUpstreamName}`}})],HomeWebviewProvider.prototype,"pullRequestCreate",1),ed([(0,F.Rm)({args:{0:e=>`${e.branchId}, worktree: ${e.worktree?.name}`}})],HomeWebviewProvider.prototype,"worktreeOpen",1),ed([(0,F.Rm)({args:{0:e=>e.branchId}})],HomeWebviewProvider.prototype,"switchToBranch",1),ed([(0,F.Rm)({args:{0:e=>e?.branchId}})],HomeWebviewProvider.prototype,"fetch",1)}};